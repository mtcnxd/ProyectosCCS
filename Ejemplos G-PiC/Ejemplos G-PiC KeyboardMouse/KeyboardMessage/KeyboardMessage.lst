CCS PCH C Compiler, Version 4.140, 50117               18-Feb-13 11:07

               Filename:   D:\Dropbox\Electronics [Dropbox]\Cursos y talleres\Curso G-PIC Lite!\Ejemplos G-PiC KeyboardMouse\KeyboardMessage\KeyboardMessage.lst

               ROM used:   5264 bytes (16%)
                           Largest free fragment is 19308
               RAM used:   244 (12%) at main() level
                           330 (16%) worst case
               Stack:     15 worst case (6 in main + 9 for interrupts)

*
2000:  GOTO   3392
*
2008:  MOVWF  04
200A:  MOVFF  FD8,05
200E:  MOVFF  FE0,06
2012:  MOVLB  0
2014:  MOVFF  FE9,0C
2018:  MOVFF  FEA,07
201C:  MOVFF  FE1,08
2020:  MOVFF  FE2,09
2024:  MOVFF  FD9,0A
2028:  MOVFF  FDA,0B
202C:  MOVFF  FF3,12
2030:  MOVFF  FF4,13
2034:  MOVFF  FFA,14
2038:  MOVFF  FF5,15
203C:  MOVFF  FF6,16
2040:  MOVFF  FF7,17
2044:  MOVFF  00,0E
2048:  MOVFF  01,0F
204C:  MOVFF  02,10
2050:  MOVFF  03,11
2054:  BTFSS  FA0.1
2056:  GOTO   2060
205A:  BTFSC  FA1.1
205C:  GOTO   231E
2060:  BTFSS  FA0.5
2062:  GOTO   206C
2066:  BTFSC  FA1.5
2068:  GOTO   2E4C
206C:  MOVFF  0E,00
2070:  MOVFF  0F,01
2074:  MOVFF  10,02
2078:  MOVFF  11,03
207C:  MOVFF  0C,FE9
2080:  MOVFF  07,FEA
2084:  BSF    07.7
2086:  MOVFF  08,FE1
208A:  MOVFF  09,FE2
208E:  MOVFF  0A,FD9
2092:  MOVFF  0B,FDA
2096:  MOVFF  12,FF3
209A:  MOVFF  13,FF4
209E:  MOVFF  14,FFA
20A2:  MOVFF  15,FF5
20A6:  MOVFF  16,FF6
20AA:  MOVFF  17,FF7
20AE:  MOVF   04,W
20B0:  MOVFF  06,FE0
20B4:  MOVFF  05,FD8
20B8:  RETFIE 0
.................... /** 
....................    KeyboardMessage 
....................    
....................    Cuando el botón BOOT es presionado, una cadena de caracteres es enviada a la  
....................    PC como entrada de teclado. Puedes usar tu editor de texto favorito para ver 
....................    el resultado. 
....................  
....................    keyboard_print() 
....................    Envía la presión de teclas hacia la computadora conectada. keyboard_print() 
....................    debe ser llamado después de haber inicializado mediante KeyboadMouse_begin(). 
....................  
....................    ADVERTENCIA: Al usar el comando keyboard_print(), la G-PiC Lite! toma el 
....................    control de tu teclado! Asegúrate de tener el control antes de utilizar este 
....................    comando. Se recomienda utilizar un push button para activar/desactivar  
....................    esta función. 
....................     
....................    Sintaxis 
....................    char text[] = "Texto a teclear!"; 
....................    keyboard_print(text); 
....................     
....................    Parametros 
....................    text: la cadena de caracteres que se desea teclear. Es necesario guardar 
....................    esta cadena en una arreglo tipo char y luego pasar este arreglo como parámetro 
....................    de la función keyboard_print(). 
....................     
....................    Devuelve 
....................    - 
....................  
....................    Se requiere que el idioma del teclado sea: 
....................     
....................    INGLÉS (Estados Unidos - Internacional). 
....................      
....................    -- 
....................    Created: 08 feb 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics 
.................... */ 
.................... #include <G-PiC Lite!.c> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #ifdef ADC_10BITS   //Define ADC_10BITS antes de llamar la biblioteca para tener esta configuracion 
....................    #device ADC = 10  
.................... #endif 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOPBADEN 
.................... #use delay(clock=48000000) 
*
2F48:  CLRF   FEA
2F4A:  MOVLW  7C
2F4C:  MOVWF  FE9
2F4E:  MOVF   FEF,W
2F50:  BZ    2F6E
2F52:  MOVLW  0F
2F54:  MOVWF  01
2F56:  CLRF   00
2F58:  DECFSZ 00,F
2F5A:  BRA    2F58
2F5C:  DECFSZ 01,F
2F5E:  BRA    2F56
2F60:  MOVLW  8F
2F62:  MOVWF  00
2F64:  DECFSZ 00,F
2F66:  BRA    2F64
2F68:  NOP   
2F6A:  DECFSZ FEF,F
2F6C:  BRA    2F52
2F6E:  RETURN 0
.................... #ifndef NO_BOOTLOADER   //Define NO_BOOTLOADER antes de llamar la biblioteca para no cargar el bootloader 
....................    #include <usb\usb_bootloader.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... //#if defined(__DEBUG) 
.................... #define LOADER_SIZE        (0x1FFF) 
.................... //#else 
.................... //#define LOADER_SIZE        (0x17FF) 
.................... //#endif 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif  
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define  USB_CONFIG_PID       0x0001 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             12, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'G',0, 
....................             '-',0, 
....................             'P',0, 
....................             'i',0, 
....................             'C',0, 
....................       //string 2 - product 
....................             24, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'G',0, 
....................             '-',0, 
....................             'P',0, 
....................             'i',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'L',0, 
....................             'i',0, 
....................             't',0, 
....................             'e',0, 
....................             '!',0, 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #endif 
.................... #include <Arduino Functions.c> 
.................... /*  
.................... This library includes the definitions to translate the most common Arduino 
.................... functions to the CCS built-in functions. To see the reference of each 
.................... instruction please refer to the CCS Help File for each CCS functions. 
....................  
.................... Esta librería incluye las definiciones para traducir las funciones de Arduino 
.................... más comunes a las funciones incluidas en CCS. Para obtener la referencia de cada  
.................... función de CCS favor de ver el archivo Help del CCS. 
.................... */ 
....................  
.................... /* Additional libraries */ 
.................... #include <analogWrite.c> 
.................... /*                                     PWM.c 
....................  
.................... Esta libreria contiene funciones diseñadas para la facil y rapida programacion 
.................... de salidas PWM por software a traves del uso del Timer3, al igual que las dos 
.................... salidas de PWM por hardware en Pin_C1 y Pin_C2. 
....................  
.................... La salida de PWM por software tiene una frecuencia aproximada de 250Hz y puede 
.................... configurar el ciclo de trabajo entre 0% y 100%, en intervalos de 10%. 
....................  
.................... La salida de PWM por hardware tiene una frecuencia aproximada de 30kHz y puede 
.................... configurar un ciclo de trabajo entre 0% y 100%, en intervalos de 1%. 
....................  
.................... Los Pins de salida del PWM se seleccionan definiendo PWMx_PIN donde x puede ser 
.................... desde 0 hasta 11. Los pines PWM por default son los siguientes: 
....................  
....................          PWM0_PIN    PIN_B0    
....................          PWM1_PIN    PIN_B1 
....................          PWM2_PIN    PIN_B2 
....................          PWM3_PIN    PIN_B3 
....................          PWM4_PIN    PIN_B4 
....................          PWM5_PIN    PIN_B5 
....................          PWM6_PIN    PIN_B6 
....................          PWM7_PIN    PIN_B7 
....................          PWM8_PIN    PIN_D0 
....................          PWM9_PIN    PIN_D1 
....................          PWM10_PIN   PIN_D2 
....................          PWM11_PIN   PIN_A4 
....................           
....................          PIN_C1 
....................          PIN_C2 
....................              
....................    En caso de seleccionar el Pin_C1 o el Pin_C2 se activará el PWM por hardware 
....................    del pin seleccionado con un ciclo configurable entre 0% y 100% en intervalos 
....................    de 1% 
.................... */ 
.................... #ifndef __Software_PWM__ 
.................... #define __Software_PWM__ 
....................  
.................... int1 _PWM0_Flag,_PWM1_Flag,_PWM2_Flag,_PWM3_Flag,_PWM4_Flag,_PWM5_Flag, 
....................      _PWM6_Flag,_PWM7_Flag,_PWM8_Flag,_PWM9_Flag,_PWM10_Flag,_PWM11_Flag; 
....................  
.................... int8 _PWM0_DutyCycle,_PWM1_DutyCycle,_PWM2_DutyCycle,_PWM3_DutyCycle, 
....................      _PWM4_DutyCycle,_PWM5_DutyCycle,_PWM6_DutyCycle,_PWM7_DutyCycle, 
....................      _PWM8_DutyCycle,_PWM9_DutyCycle,_PWM10_DutyCycle,_PWM11_DutyCycle; 
....................  
.................... #ifndef PWM0_PIN 
....................    #define PWM0_PIN  PIN_B0       //Pin para PWM0 
.................... #endif 
.................... #ifndef PWM1_PIN 
....................    #define PWM1_PIN  PIN_B1       //Pin para PWM1 
.................... #endif 
.................... #ifndef PWM2_PIN 
....................    #define PWM2_PIN  PIN_B2       //Pin para PWM2 
.................... #endif 
.................... #ifndef PWM3_PIN 
....................    #define PWM3_PIN  PIN_B3       //Pin para PWM3 
.................... #endif 
.................... #ifndef PWM4_PIN 
....................    #define PWM4_PIN  PIN_B4       //Pin para PWM4 
.................... #endif 
.................... #ifndef PWM5_PIN 
....................    #define PWM5_PIN  PIN_B5       //Pin para PWM5 
.................... #endif 
.................... #ifndef PWM6_PIN 
....................    #define PWM6_PIN  PIN_B6       //Pin para PWM6 
.................... #endif 
.................... #ifndef PWM7_PIN 
....................    #define PWM7_PIN  PIN_B7       //Pin para PWM7 
.................... #endif 
.................... #ifndef PWM8_PIN 
....................    #define PWM8_PIN  PIN_D0       //Pin para PWM8 
.................... #endif 
.................... #ifndef PWM9_PIN 
....................    #define PWM9_PIN  PIN_D1       //Pin para PWM9 
.................... #endif 
.................... #ifndef PWM10_PIN 
....................    #define PWM10_PIN PIN_D2       //Pin para PWM10 
.................... #endif 
.................... #ifndef PWM11_PIN              
....................    #define PWM11_PIN PIN_A4       //Pin para PWM11 
.................... #endif 
....................  
.................... #define _Set_PWM_Timer3 63135 
.................... #define _totalResolution 10 
....................  
....................  
.................... //****************************************************************************/ 
.................... //                         analogWrite(PWMx,DutyCycle) 
.................... // 
.................... //Funcion que permite la configuracion de PWM por software en cualquier PIN 
.................... //digital disponible. En caso de necesitar mas pines PWM es posible agregarlos  
.................... //añadiendo mas "case" siguiendo la secuencia en las variables. 
.................... // 
.................... // PWMx => Especifica el numero de PWM, cada salida debe tener uno diferente 
.................... // DutyCycle => Porcentaje de ciclo de trabajo del PWM. Es un valor de 0 a 100 
.................... // 
.................... // Ejemplo: 
.................... //          PWM_Output(0,50);   //Salida PWM0 de 50% 
.................... //          PWM_Output(1,0);    //Salida PWM1 de 0% 
.................... //                              //y apaga el PWM para uso como I/O 
.................... //****************************************************************************// 
.................... void analogWrite(int8 _PWMx, int8 _DutyCycle) { 
....................    static int1 _T3_Config_Flag = False, _T2_Config_Flag = False; 
....................    //Pregunta si el Timer3 ya ha sido configurado 
....................    //Si el Pin corresponde a un pin de PWM por hardware, no configura el timer3 
....................    if(!_T3_Config_Flag && _PWMx != Pin_C1 && _PWMx != Pin_C2) { 
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_2); 
....................       set_timer3(_Set_PWM_Timer3); 
....................        
....................       enable_interrupts(GLOBAL); 
....................       enable_interrupts(INT_TIMER3); 
....................       _T3_Config_Flag = True;    //Indica que el Timer3 ya ha sido configurado 
....................    }    
....................     
....................    //Si no es un pin de PWM por hardware, divide entre 5 el ciclo de trabajo  
....................    //para convertirlo en un valor entre 0 y 20 
....................    if(_PWMx != Pin_C1 && _PWMx != Pin_C2)    _DutyCycle /= 10; 
....................    else { 
....................       if(!_T2_Config_Flag) {          //Configura por única vez el Timer2 
....................          setup_timer_2(T2_DIV_BY_4, 100, 1); 
....................          _T2_Config_Flag = True; 
....................       } 
....................    } 
....................            
....................    if(_DutyCycle == 0) { 
....................       switch(_PWMx) {                 //Desactiva la salida PWM en el PIN deseado 
....................          case 0: 
....................             _PWM0_Flag = False; 
....................             output_low(PWM0_PIN); 
....................             break; 
....................          case 1: 
....................             _PWM1_Flag = False; 
....................             output_low(PWM1_PIN); 
....................             break; 
....................          case 2: 
....................             _PWM2_Flag = False; 
....................             output_low(PWM2_PIN); 
....................             break;    
....................          case 3: 
....................             _PWM3_Flag = False; 
....................             output_low(PWM3_PIN); 
....................             break; 
....................          case 4: 
....................             _PWM4_Flag = False; 
....................             output_low(PWM4_PIN); 
....................             break; 
....................          case 5: 
....................             _PWM5_Flag = False; 
....................             output_low(PWM5_PIN); 
....................             break;    
....................          case 6: 
....................             _PWM6_Flag = False; 
....................             output_low(PWM6_PIN); 
....................             break;    
....................          case 7: 
....................             _PWM7_Flag = False; 
....................             output_low(PWM7_PIN); 
....................             break; 
....................          case 8: 
....................             _PWM8_Flag = False; 
....................             output_low(PWM8_PIN); 
....................             break; 
....................          case 9: 
....................             _PWM9_Flag = False; 
....................             output_low(PWM9_PIN); 
....................             break; 
....................          case 10: 
....................             _PWM10_Flag = False; 
....................             output_low(PWM10_PIN); 
....................             break; 
....................          case 11: 
....................             _PWM11_Flag = False; 
....................             output_low(PWM11_PIN); 
....................             break;  
....................          case Pin_C1: 
....................             setup_ccp2(CCP_OFF); 
....................             output_low(Pin_C1); 
....................             break; 
....................          case Pin_C2: 
....................             setup_ccp1(CCP_OFF); 
....................             output_low(Pin_C2); 
....................             break;             
....................          default: 
....................          break; 
....................       } 
....................    } 
....................    else { 
....................       switch(_PWMx)                    //Asigna una salida PWM en el PIN deseado 
....................       {                  
....................          case 0: 
....................             _PWM0_Flag = True; 
....................             _PWM0_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 1: 
....................             _PWM1_Flag = True; 
....................             _PWM1_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 2: 
....................             _PWM2_Flag = True; 
....................             _PWM2_DutyCycle = _DutyCycle; 
....................             break;    
....................          case 3: 
....................             _PWM3_Flag = True; 
....................             _PWM3_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 4: 
....................             _PWM4_Flag = True; 
....................             _PWM4_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 5: 
....................             _PWM5_Flag = True; 
....................             _PWM5_DutyCycle = _DutyCycle; 
....................             break;    
....................          case 6: 
....................             _PWM6_Flag = True; 
....................             _PWM6_DutyCycle = _DutyCycle; 
....................             break;    
....................          case 7: 
....................             _PWM7_Flag = True; 
....................             _PWM7_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 8: 
....................             _PWM8_Flag = True; 
....................             _PWM8_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 9: 
....................             _PWM9_Flag = True; 
....................             _PWM9_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 10: 
....................             _PWM10_Flag = True; 
....................             _PWM10_DutyCycle = _DutyCycle; 
....................             break; 
....................          case 11: 
....................             _PWM11_Flag = True; 
....................             _PWM11_DutyCycle = _DutyCycle; 
....................             break; 
....................          case Pin_C1:                        //PWM por hardware 
....................             setup_ccp2(CCP_PWM); 
....................             set_pwm2_duty(_DutyCycle); 
....................             break; 
....................          case Pin_C2: 
....................             setup_ccp1(CCP_PWM);             //PWM por hardware 
....................             set_pwm1_duty(_DutyCycle); 
....................             break; 
....................          default: 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
.................... //****************************************************************************// 
.................... //                               Timer3_Interrupt() 
.................... //****************************************************************************// 
.................... #INT_TIMER3 
.................... void Timer3_Interrupt() 
.................... {    
....................    set_timer3(_Set_PWM_Timer3); 
*
231E:  MOVLW  F6
2320:  MOVWF  FB3
2322:  MOVLW  9F
2324:  MOVWF  FB2
....................    static int8 T3_Counter = 1; 
....................     
....................    if(_PWM0_Flag) 
2326:  BTFSS  1A.0
2328:  BRA    233A
....................    { 
....................       if (T3_Counter <= _PWM0_DutyCycle) output_high(PWM0_PIN);  
232A:  MOVF   29,W
232C:  SUBWF  1C,W
232E:  BNC   2336
2330:  BCF    F93.0
2332:  BSF    F8A.0
....................       else output_low(PWM0_PIN); 
2334:  BRA    233A
2336:  BCF    F93.0
2338:  BCF    F8A.0
....................    } 
....................     
....................    if(_PWM1_Flag) 
233A:  BTFSS  1A.1
233C:  BRA    234E
....................    { 
....................       if (T3_Counter <= _PWM1_DutyCycle) output_high(PWM1_PIN);  
233E:  MOVF   29,W
2340:  SUBWF  1D,W
2342:  BNC   234A
2344:  BCF    F93.1
2346:  BSF    F8A.1
....................       else output_low(PWM1_PIN); 
2348:  BRA    234E
234A:  BCF    F93.1
234C:  BCF    F8A.1
....................    } 
....................     
....................    if(_PWM2_Flag) 
234E:  BTFSS  1A.2
2350:  BRA    2362
....................    { 
....................       if (T3_Counter <= _PWM2_DutyCycle) output_high(PWM2_PIN);  
2352:  MOVF   29,W
2354:  SUBWF  1E,W
2356:  BNC   235E
2358:  BCF    F93.2
235A:  BSF    F8A.2
....................       else output_low(PWM2_PIN); 
235C:  BRA    2362
235E:  BCF    F93.2
2360:  BCF    F8A.2
....................    } 
....................     
....................    if(_PWM3_Flag) 
2362:  BTFSS  1A.3
2364:  BRA    2376
....................    { 
....................       if (T3_Counter <= _PWM3_DutyCycle) output_high(PWM3_PIN);  
2366:  MOVF   29,W
2368:  SUBWF  1F,W
236A:  BNC   2372
236C:  BCF    F93.3
236E:  BSF    F8A.3
....................       else output_low(PWM3_PIN); 
2370:  BRA    2376
2372:  BCF    F93.3
2374:  BCF    F8A.3
....................    } 
....................     
....................    if(_PWM4_Flag) 
2376:  BTFSS  1A.4
2378:  BRA    238A
....................    { 
....................       if (T3_Counter <= _PWM4_DutyCycle) output_high(PWM4_PIN);  
237A:  MOVF   29,W
237C:  SUBWF  20,W
237E:  BNC   2386
2380:  BCF    F93.4
2382:  BSF    F8A.4
....................       else output_low(PWM4_PIN); 
2384:  BRA    238A
2386:  BCF    F93.4
2388:  BCF    F8A.4
....................    } 
....................     
....................    if(_PWM5_Flag) 
238A:  BTFSS  1A.5
238C:  BRA    239E
....................    { 
....................       if (T3_Counter <= _PWM5_DutyCycle) output_high(PWM5_PIN);  
238E:  MOVF   29,W
2390:  SUBWF  21,W
2392:  BNC   239A
2394:  BCF    F93.5
2396:  BSF    F8A.5
....................       else output_low(PWM5_PIN); 
2398:  BRA    239E
239A:  BCF    F93.5
239C:  BCF    F8A.5
....................    } 
....................     
....................    if(_PWM6_Flag) 
239E:  BTFSS  1A.6
23A0:  BRA    23B2
....................    { 
....................       if (T3_Counter <= _PWM6_DutyCycle) output_high(PWM6_PIN);  
23A2:  MOVF   29,W
23A4:  SUBWF  22,W
23A6:  BNC   23AE
23A8:  BCF    F93.6
23AA:  BSF    F8A.6
....................       else output_low(PWM6_PIN); 
23AC:  BRA    23B2
23AE:  BCF    F93.6
23B0:  BCF    F8A.6
....................    } 
....................     
....................    if(_PWM7_Flag) 
23B2:  BTFSS  1A.7
23B4:  BRA    23C6
....................    { 
....................       if (T3_Counter <= _PWM7_DutyCycle) output_high(PWM7_PIN);  
23B6:  MOVF   29,W
23B8:  SUBWF  23,W
23BA:  BNC   23C2
23BC:  BCF    F93.7
23BE:  BSF    F8A.7
....................       else output_low(PWM7_PIN); 
23C0:  BRA    23C6
23C2:  BCF    F93.7
23C4:  BCF    F8A.7
....................    } 
....................     
....................    if(_PWM8_Flag) 
23C6:  BTFSS  1B.0
23C8:  BRA    23DA
....................    { 
....................       if (T3_Counter <= _PWM8_DutyCycle) output_high(PWM8_PIN);  
23CA:  MOVF   29,W
23CC:  SUBWF  24,W
23CE:  BNC   23D6
23D0:  BCF    F95.0
23D2:  BSF    F8C.0
....................       else output_low(PWM8_PIN); 
23D4:  BRA    23DA
23D6:  BCF    F95.0
23D8:  BCF    F8C.0
....................    } 
....................     
....................    if(_PWM9_Flag) 
23DA:  BTFSS  1B.1
23DC:  BRA    23EE
....................    { 
....................       if (T3_Counter <= _PWM9_DutyCycle) output_high(PWM9_PIN);  
23DE:  MOVF   29,W
23E0:  SUBWF  26,W
23E2:  BNC   23EA
23E4:  BCF    F95.1
23E6:  BSF    F8C.1
....................       else output_low(PWM9_PIN); 
23E8:  BRA    23EE
23EA:  BCF    F95.1
23EC:  BCF    F8C.1
....................    } 
....................     
....................    if(_PWM10_Flag) 
23EE:  BTFSS  1B.2
23F0:  BRA    2402
....................    { 
....................       if (T3_Counter <= _PWM10_DutyCycle) output_high(PWM10_PIN);  
23F2:  MOVF   29,W
23F4:  SUBWF  27,W
23F6:  BNC   23FE
23F8:  BCF    F95.2
23FA:  BSF    F8C.2
....................       else output_low(PWM10_PIN); 
23FC:  BRA    2402
23FE:  BCF    F95.2
2400:  BCF    F8C.2
....................    } 
....................     
....................    if(_PWM11_Flag) 
2402:  BTFSS  1B.3
2404:  BRA    2416
....................    { 
....................       if (T3_Counter <= _PWM11_DutyCycle) output_high(PWM11_PIN);  
2406:  MOVF   29,W
2408:  SUBWF  28,W
240A:  BNC   2412
240C:  BCF    F92.4
240E:  BSF    F89.4
....................       else output_low(PWM11_PIN); 
2410:  BRA    2416
2412:  BCF    F92.4
2414:  BCF    F89.4
....................    } 
....................     
....................    T3_Counter ++; 
2416:  INCF   29,F
....................    if(T3_Counter > _totalResolution) T3_Counter = 1; 
2418:  MOVF   29,W
241A:  SUBLW  0A
241C:  BC    2422
241E:  MOVLW  01
2420:  MOVWF  29
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* Reserved words and names definitions */ 
.................... #define digitalToggle   output_toggle 
.................... #define digitalWrite    output_bit 
.................... #define digitalRead     input 
....................  
.................... //****************************************************************************// 
.................... //                               analogRead(_Channel) 
.................... //Lee cualquiera de las entradas analógicas de la G-PiC Lite!. No es necesario 
.................... //poner un delay entre cada lectura, pues este tiempo está incluido dentro de la 
.................... //función. 
.................... // 
.................... //NOTA: Se emplea para lecturas de 8 bits de resolucion 
.................... //****************************************************************************// 
.................... #define A0  0 
.................... #define A1  1 
.................... #define A2  2 
.................... #define A3  3 
.................... #define A4  4 
.................... #define A5  5 
.................... #define A6  6 
.................... #define A7  7 
.................... #define A8  8 
.................... #define A9  9 
.................... #define A10 10 
.................... #define A11 11 
.................... #define A12 12 
....................  
2422:  BCF    FA1.1
2424:  GOTO   206C
.................... int16 analogRead(int _Channel) 
.................... { 
....................    int16 _adcReading; 
....................     
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................    setup_adc_ports(ALL_ANALOG); 
....................    set_adc_channel(_Channel); 
....................    delay_us(10); 
....................     
....................    _adcReading = read_adc(); 
....................       
....................    setup_adc_ports(NO_ANALOGS); 
....................    return(_adcReading); 
.................... } 
....................  
.................... /** 
.................... *  Funciones para comunicación Serial UART RS232 
.................... */ 
.................... #define Serial_write       putc 
.................... #define Serial_read        getc 
.................... #define Serial_available   kbhit 
.................... #define Serial_baudrate    set_uart_speed 
.................... #define SoftSerial_baudrate    set_uart_speed 
....................  
.................... void Serial_begin() { 
....................    #use RS232(UART1, Baud = 9600, errors)    
.................... } 
....................  
.................... void SoftSerial1_begin() { 
....................    #use RS232(Stream = SoftSerial1, Baud = 9600, xmit = Pin_D4, rcv = Pin_D5, errors, disable_ints) 
.................... } 
....................  
.................... void SoftSerial2_begin() { 
....................    #use RS232(Stream = SoftSerial2, Baud = 9600, xmit = Pin_D6, rcv = Pin_D7, errors, disable_ints) 
.................... } 
....................  
.................... void SoftSerial1_write(int _data) { 
....................    fputc(_data, SoftSerial1); 
.................... } 
.................... void SoftSerial2_write(int _data) { 
....................    fputc(_data, SoftSerial2); 
.................... } 
....................  
.................... int SoftSerial1_read() { 
....................    return(fgetc(SoftSerial1)); 
.................... } 
.................... int SoftSerial2_read() { 
....................    return(fgetc(SoftSerial2)); 
.................... } 
....................  
.................... int1 SoftSerial1_available() { 
....................    return(kbhit(SoftSerial1)); 
.................... } 
.................... int1 SoftSerial2_available() { 
....................    return(kbhit(SoftSerial2)); 
.................... } 
....................  
....................  
.................... #define Reset_GPiC   reset_cpu   // Ejecuta un reset. Útil para finalizar la conexión USB 
....................  
.................... /** 
.................... *  Recibe una variable con valores entre 0-255 y convierte los valores en un 
.................... *  rango entre 0-100. 
.................... *  Esta función es particularmente útil para asignar valores de porcentaje PWM 
.................... */ 
.................... int8 convert255to100(int8 _value) { 
....................    return((_value*100.0)/255.0); 
.................... } 
....................  
.................... /** 
.................... *  Recibe una variable con valores entre 0-255 y lo convierte a su equivalente 
.................... *  en voltaje entre 0V y 5V. Util para variables que contengan valores analógicos 
.................... */ 
.................... float convertDECtoVolt(float _value) { 
....................    _value = (_value*5)/255; 
....................    return(_value); 
.................... } 
....................  
.................... /** 
.................... *  Convierte el valor analogico leido de un LM35 y lo convierte en su equivalente 
.................... *  en grados. 
.................... */ 
.................... float convertDECtoDegree(float _value) { 
....................    _value = 100*(_value*5)/255; 
....................    return(_value); 
.................... } 
....................  
.................... /** 
.................... *  Permite controlar el estado lógico de diversos pines de salida a la vez. 
.................... *  
.................... *  Parametros: 
.................... * 
.................... *  _pins[] - Un arreglo que contiene los pines que se desea controlar 
.................... *  _pinCount - El numero total de pines que se desea controlar 
.................... *  _value - Un valor de n bits conteniendo el estado logico de los bits que  
....................             representan cada pin, donde "n" es el numero de pines seleccionados. 
....................             Para una mejor interpretación, se sugiere representar este valor en 
....................             formato binario. 
.................... */ 
.................... void output_pins(int16 _pins[], int _pinCount, int16 _value) { 
....................    int8 _i; 
....................    for(_i = 0; _i < _pinCount; _i++) { 
....................       output_bit(_pins[_i], bit_test(_value, _i)); 
....................    } 
.................... } 
....................  
.................... #define PinA0 0 
.................... #define PinA1 1 
.................... #define PinA2 2 
.................... #define PinA3 3 
.................... #define PinA4 4 
.................... #define PinA5 5 
.................... #define PinE0 6 
.................... #define PinE1 7 
.................... #define PinE2 8 
.................... #define PinC0 9 
.................... #define PinC1 10 
.................... #define PinC2 11 
.................... #define PinD0 12 
.................... #define PinD1 13 
.................... #define PinD2 14 
.................... #define PinD3 15 
.................... #define PinC6 16 
.................... #define PinC7 17 
.................... #define PinD4 18 
.................... #define PinD5 19 
.................... #define PinD6 20 
.................... #define PinD7 21 
.................... #define PinB0 22 
.................... #define PinB1 23 
.................... #define PinB2 24 
.................... #define PinB3 25 
.................... #define PinB4 26 
.................... #define PinB5 27 
.................... #define PinB6 28 
.................... #define PinB7 29 
.................... #define _numberPins {Pin_A0, Pin_A1, Pin_A2, Pin_A3, Pin_A4, Pin_A5, \ 
....................                      Pin_E0, Pin_E1, Pin_E2, Pin_C0, Pin_C1, Pin_C2, \ 
....................                      Pin_D0, Pin_D1, Pin_D2, Pin_D3, Pin_C6, Pin_C7, \ 
....................                      Pin_D4, Pin_D5, Pin_D6, Pin_D7, Pin_B0, Pin_B1, \ 
....................                      Pin_B2, Pin_B3, Pin_B4, Pin_B5, Pin_B6, Pin_B7} 
....................  
....................  
.................... /** 
.................... *  Permite controlar el estado lógico de un solo pin a base de numeros 
.................... *  
.................... *  Parametros: 
.................... * 
.................... *  _pin - El numero del pin que se desea modificar 
.................... *  _state - Estado que se asignara al pin 
.................... */ 
.................... void digitalWrite2(int8 _pin, int1 _state){ 
....................    const int16 _pins[30] = _numberPins; 
....................    output_bit(_pins[_pin], _state); 
.................... } 
....................  
.................... /** 
.................... *  Permite verificar el estado lógico de un solo pin a base de numeros 
.................... *  
.................... *  Parametros: 
.................... * 
.................... *  _pin - El numero del pin que se desea saber su estado 
.................... */ 
.................... int1 digitalRead2(int8 _pin){ 
....................    const int16 _pins[30] = _numberPins; 
....................    return input(_pins[_pin]); 
.................... } 
....................  
.................... #include <SensorModules.c> 
.................... /** 
....................    Esta librería contiene funciones que facilitan el uso de diversos sensores 
....................    y módulos comúnmente utilizados. 
....................     
....................    Created:    Ene 2013 
....................    by:         Ing. Ayrton Estrella 
....................    Change log:  
....................       Beta release 
.................... */ 
....................  
.................... /** 
.................... *  Funciones para el sensor ultrasónico SR04 
.................... */ 
.................... //!int16 SR04_getDistance(int16 _triggerPin, int16 _echoPin) { 
.................... //!   int16 _microseconds; 
.................... //!   int16 _distance; 
.................... //!    
.................... //!   digitalWrite(_triggerPin, 1); 
.................... //!   delay_us(15); 
.................... //!   digitalWrite(_triggerPin, 0); 
.................... //!   while(digitalRead(_echoPin) == 0) { 
.................... //!      _microseconds ++; 
.................... //!      if(_microseconds == 2500) return(0); 
.................... //!   } 
.................... //!   _microseconds = 0; 
.................... //!   while(digitalRead(_echoPin) == 1) { 
.................... //!      _microseconds ++; 
.................... //!      delay_us(1); 
.................... //!   } 
.................... //!    
.................... //!   _distance = _microseconds/6; 
.................... //!   return(_distance); 
.................... //!} 
....................  
....................  
....................  
.................... #include <G-PiC KeyboardMouse.c> 
.................... /** 
....................    G-PiC KeyboardMouse.c 
....................     
....................    This library is based on the Arduino Keyboard Library, found on this website: 
....................       http://arduino.cc/en/Reference/MouseKeyboard 
....................        
....................    -- 
....................    Created: 14 feb 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics 
.................... */ 
.................... #include "KeyboardMouse_Descriptor.h" 
.................... #include <pic18_usb.h>                             //Microchip PIC18Fxx5x Hardware layer for CCS's PIC USB driver 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include "usb\usb_hw_layer.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0055 
.................... #define  USB_CONFIG_VID       0x0461 
.................... #define  USB_CONFIG_BUS_POWER 500   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... #DEFINE USB_HID_DEVICE  TRUE 
....................  
.................... //the following defines needed for the CCS USB PIC driver to enable the TX endpoint 1 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for IN bulk/interrupt transfers 
.................... #define USB_EP1_TX_SIZE 8 
....................  
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP2 for IN bulk/interrupt transfers 
.................... #define USB_EP2_TX_SIZE 8 
....................  
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP2 for IN bulk/interrupt transfers 
.................... #define USB_EP2_RX_SIZE 4 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    /// 
....................    ///  HID Report.  Tells HID driver how to handle and deal with 
....................    ///  received data.  HID Reports can be extremely complex, 
....................    ///  see HID specifcation for help on writing your own. 
....................    /// 
....................    ///  First it defines a block for the first interface for a mouse 
....................    ///  protocol.  Second it defines a block for the second interface 
....................    ///  for a keyboard protocol. 
....................    /// 
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_CLASS_SPECIFIC_DESC[] =  
....................    { 
....................     //hid report descriptor for interface 0 (mouse) 
....................       0x05, 0x01, // usage page (generic desktop Choose the usage page "mouse" is on   //0,1 
....................       0x09, 0x02, // usage (mouse) Device is a mouse  //2,3 
....................       0xA1, 0x01, // collection (application) This collection encompasses the report format  //4,5 
....................       0x09, 0x01, // usage (pointer) Choose the key code usage page  //6,7 
....................       0xA1, 0x00, // collection (physical) Physical collection //8,9 
....................       0x05, 0x09, // usage page (buttons) Choose the button usage page   //10,11 
....................       0x19, 0x01, // usage minimum (1) There are three buttons //12,13 
....................       0x29, 0x03, // usage maximum (3) //14,15 
....................       0x15, 0x00, // logical minimum (0) Each button is represented by one bit   //16,17 
....................       0x25, 0x01, // logical maximum (1)  //18,19 
....................       0x95, 0x03, // report count (3) Three reports, one bit each //20,21 
....................       0x75, 0x01, // report size (1)   //22, 23 
....................       0x81, 0x02, // input (data, variable, absolute) Defined bits above are data bits //24,25 
....................       0x95, 0x01, // report count (1) One report, five bits in length   //26, 27 
....................       0x75, 0x05, // report size (5)   //28, 29 
....................       0x81, 0x01, // input (constant) Bit stuff to fill byte   //30, 31 
....................       0x05, 0x01, // usage page (generic desktop) Choose the usage pare X and Y are on   //32, 33 
....................       0x09, 0x30, // usage (X) X direction of pointer //34, 35 
....................       0x09, 0x31, // usage (Y) Y direction of pointer //36, 37 
....................       0x09, 0x38  // usage (wheel)  //38, 39 
....................       0x15, 0x81, // logical minimum (-127) Range of report data is -127 to 127  //40,41 
....................       0x25, 0x7F, // logical maximum (127)   //42, 43 
....................       0x75, 0x08, // report size (8) Two reports, eight bits each //44, 45 
....................       0x95, 0x03, // report count (3)  //46, 47 
....................       0x81, 0x06, // input (data, variable, absolute) Defined bits above are data bits //48, 49 
....................       0xC0,       // end collection End physical collection //50 
....................       0xC0        // end collection End application collection //51 
....................     //hid report descriptor for interface 1 (keyboard) 
....................       0x05, 0x01, //usage page (generic desktop)   //52, 53 
....................       0x09, 0x06, //usage (keyboard)   //54, 55 
....................       0xA1, 0x01, //collection (application) //56, 57 
....................       0x05, 0x07, //usage page (key codes)   //58, 59 
....................       0x19, 0xE0, //usage min (224) //60, 61 
....................       0x29, 0xE7, //usage max (231) //62, 63 
....................       0x15, 0x00, //logical min (0) //64, 65 
....................       0x25, 0x01, //logical max (1) //66, 67 
....................       0x75, 0x01, //report size (1) //68, 69 
....................       0x95, 0x08, //report count (8)   //70, 71 
....................       0x81, 0x02, //input (data, variable, absolute) [modifier byte] //72, 73 
....................       0x95, 0x01, //report count (1)   //74, 75 
....................       0x75, 0x08, //report size (8)    //76, 77 
....................       0x81, 0x01, //input (constant) [reserved byte]  //78, 79 
....................       0x95, 0x05, //report count (5)   //80, 81 
....................       0x75, 0x01, //report size (1)    //82, 83 
....................       0x05, 0x08, //usage page (page# for leds) //84, 85 
....................       0x19, 0x01, //usage min (1)   //86, 87 
....................       0x29, 0x05, //usage max (5)   //88, 89 
....................       0x91, 0x02, //output (data, var, abs) [led report] //90, 91 
....................       0x95, 0x01, //report count (1)   //92, 93 
....................       0x75, 0x03, //report size (3) //94, 95 
....................       0x91, 0x01, //output (constant) [led report padding]  //96, 97 
....................       0x95, 0x05, //report count (5)   //98, 99 
....................       0x75, 0x08, //report size (8) //100, 101 
....................       0x15, 0x00, //logical min (0) //102, 103 
....................       0x25, 0x65, //logical max (101)  //104, 105 
....................       0x05, 0x07, //usage page (key codes)   //106, 107 
....................       0x19, 0x00, //usage min (0)   //108, 109 
....................       0x29, 0x65, //usage max (101) //110, 111 
....................       0x81, 0x00, //input (data, array)   //112, 113 
....................       0xC0        //end collection  //114 
....................    }; 
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines where to look for it in the const 
....................    // USB_CLASS_SPECIFIC_DESC[] array. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP[USB_NUM_CONFIGURATIONS][2] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          0, 
....................       //interface 1 
....................          52 
....................    }; 
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines the size of that descriptor. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[USB_NUM_CONFIGURATIONS][2] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          52, 
....................       //interface 1 
....................          63 
....................    }; 
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      66 //config+interface+class+endpoint 
....................  
....................    const char USB_CONFIG_DESC[] = 
....................    { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................     
....................    //interface descriptor 1 (MOUSE) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints for this interface  //13 
....................          0x03, //class code, 03 = HID     ==14 
....................          0x01, //subclass code //boot     ==15 
....................          0x02, //protocol code (mouse)      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor 1  (HID) 
....................          USB_DESC_CLASS_LEN, //length of descriptor    ==18 
....................          USB_DESC_CLASS_TYPE, //dscriptor type (0x21 == HID)      ==19 
....................          0x00,0x01, //hid class release number (1.0)      ==20,21 
....................          0x00, //localized country code (0 = none)       ==22 
....................          0x01, //number of hid class descrptors that follow (1)      ==23 
....................          0x22, //report descriptor type (0x22 == HID)                ==24 
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][0], 0x00, //length of report descriptor            ==25,26 
....................  
....................    //endpoint descriptor 1 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==27 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==28 
....................          0x81, //endpoint number and direction (0x81 = EP1 IN)       ==29 
....................          USB_ENDPOINT_TYPE_INTERRUPT, //transfer type supported (0x03 is interrupt)         ==30 
....................          USB_EP1_TX_SIZE,0x00, //maximum packet size supported                  ==31,32 
....................          10,  //polling interval, in ms.  (cant be smaller than 10 for slow speed devices)     ==33 
....................  
....................    //interface descriptor 2 (KEYBOARD) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =34 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =35 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==36 
....................          0x00, //alternate setting     ==37 
....................          2, //number of endpoints for this interface  //38 
....................          0x03, //class code, 03 = HID     ==39 
....................          0x01, //subclass code //boot     ==40 
....................          0x01, //protocol code (keyboard)      ==41 
....................          0x00, //index of string descriptor for interface      ==42 
....................  
....................    //class descriptor 2  (HID) 
....................          USB_DESC_CLASS_LEN, //length of descriptor    ==43 
....................          USB_DESC_CLASS_TYPE, //dscriptor type (0x21 == HID)      ==44 
....................          0x00,0x01, //hid class release number (1.0) (try 1.10)      ==45,46 
....................          0x00, //localized country code (0 = none)       ==47 
....................          0x01, //number of hid class descrptors that follow (1)      ==48 
....................          0x22, //report descriptor type (0x22 == HID)                ==49 
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][1], 0x00, //length of report descriptor            ==50,51 
....................  
....................    //endpoint descriptor 2 IN 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==52 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==53 
....................          0x82, //endpoint number and direction (0x81 = EP1 IN)       ==54 
....................          USB_ENDPOINT_TYPE_INTERRUPT, //transfer type supported (0x03 is interrupt)         ==55 
....................          USB_EP2_TX_SIZE,0x00, //maximum packet size supported                  ==56,57 
....................          10,  //polling interval, in ms.  (cant be smaller than 10 for slow speed devices)     ==58 
....................  
....................    //endpoint descriptor 2 OUT 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==59 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==60 
....................          0x02, //endpoint number and direction (0x81 = EP1 IN)       ==61 
....................          USB_ENDPOINT_TYPE_INTERRUPT, //transfer type supported (0x03 is interrupt)         ==62 
....................          USB_EP2_RX_SIZE,0x00, //maximum packet size supported                  ==63,64 
....................          10  //polling interval, in ms.  (cant be smaller than 10 for slow speed devices)     ==65 
....................    }; 
....................  
....................  
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   2 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][2][1]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1 
....................          18, 
....................       //interface 1 
....................          //class 1 
....................          43 
....................    }; 
....................  
....................    //****** END CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[] = { 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==1 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==2 
....................          0x10,0x01, //usb version in bcd (pic167xx is 1.1) ==3,4 
....................          0x00, //class code ==5 
....................          0x00, //subclass code ==6 
....................          0x00, //protocol code ==7 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==8 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==15 
....................          0x02, //index of string descriptor of the product  ==16 
....................          0x00, //index of string descriptor of serial number  ==17 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==18 
....................    }; 
....................  
....................    #if (sizeof(USB_DEVICE_DESC) != USB_DESC_DEVICE_LEN) 
....................       #error USB_DESC_DEVICE_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... const char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... //number of strings you have, including string 0. 
.................... #define USB_STRING_DESC_COUNT sizeof(USB_STRING_DESC_OFFSET) 
....................  
.................... // Here is where the "CCS" Manufacturer string and "CCS USB Mouse/Keyboard" are stored. 
.................... // Strings are saved as unicode. 
.................... char const USB_STRING_DESC[] = 
.................... { 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
.................... //!         0x09,0x04,   //Microsoft Defined for US-English 
....................          0x0A,0x08,   //Microsoft Defined for Mexican-Spanish ver doc. USB LANGIDs.PDF 
....................    //string 1 
....................          12, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'G',0, 
....................          '-',0, 
....................          'P',0, 
....................          'i',0, 
....................          'C',0, 
....................    //string 2 
....................          46, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'G',0, 
....................          '-',0, 
....................          'P',0, 
....................          'i',0, 
....................          'C',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          'K',0, 
....................          'e',0, 
....................          'y',0, 
....................          'b',0, 
....................          'o',0, 
....................          'a',0, 
....................          'r',0, 
....................          'd',0, 
....................          '/',0, 
....................          'M',0, 
....................          'o',0, 
....................          'u',0, 
....................          's',0, 
....................          'e',0, 
.................... }; 
....................  
.................... #include <usb.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include "usb\usb.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include "usb\pic_usb.c" 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include "usb\pic18_usb.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE "usb\usb.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
2BB8:  CLRF   03
2BBA:  MOVF   x95,W
2BBC:  ADDLW  70
2BBE:  MOVWF  FE9
2BC0:  MOVLW  0F
2BC2:  ADDWFC 03,W
2BC4:  MOVWF  FEA
2BC6:  MOVF   FEF,F
2BC8:  BZ    2BEE
2BCA:  MOVF   x95,W
2BCC:  MULLW  08
2BCE:  MOVF   FF3,W
2BD0:  CLRF   x97
2BD2:  MOVWF  x96
2BD4:  MOVLW  04
2BD6:  ADDWF  x96,F
2BD8:  MOVLW  00
2BDA:  ADDWFC x97,F
2BDC:  MOVFF  96,FE9
2BE0:  MOVLW  04
2BE2:  ADDWF  x97,W
2BE4:  MOVWF  FEA
2BE6:  MOVFF  FEF,98
2BEA:  BTFSS  x98.7
2BEC:  BRA    2BF2
2BEE:  MOVLW  00
2BF0:  BRA    2BF4
2BF2:  MOVLW  01
2BF4:  MOVWF  01
.................... } 
2BF6:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
2ECA:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
2ECC:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
2ECE:  MOVLW  08
2ED0:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
2ED2:  MOVF   F94,W
2ED4:  IORLW  30
2ED6:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
2ED8:  CLRF   30
2EDA:  CLRF   19
2EDC:  BTFSC  FF2.7
2EDE:  BSF    19.7
2EE0:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
2EE2:  CALL   2512
2EE6:  BTFSC  19.7
2EE8:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
2EEA:  GOTO   2EF0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
2EF4:  CLRF   19
2EF6:  BTFSC  FF2.7
2EF8:  BSF    19.7
2EFA:  BCF    FF2.7
....................    usb_token_reset(); 
2EFC:  CALL   2512
2F00:  BTFSC  19.7
2F02:  BSF    FF2.7
....................    UCON = 0; 
2F04:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
2F06:  MOVLW  14
2F08:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
2F0A:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
2F0C:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
2F0E:  MOVLW  01
2F10:  MOVWF  30
.................... } 
2F12:  GOTO   2F1C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
2EEE:  BRA    2ECA
.................... } 
2EF0:  GOTO   2F3C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
2F16:  BTFSC  F6D.3
2F18:  BRA    2F1C
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
2F1A:  BRA    2EF4
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
2F1C:  DECFSZ 30,W
2F1E:  BRA    2F36
2F20:  BTFSC  F6D.5
2F22:  BRA    2F36
....................    { 
....................       UIR=0; 
2F24:  CLRF   F68
....................       UIE=0; 
2F26:  CLRF   F69
....................       enable_interrupts(INT_USB); 
2F28:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
2F2A:  MOVLW  C0
2F2C:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
2F2E:  MOVLW  11
2F30:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
2F32:  MOVLW  02
2F34:  MOVWF  30
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
2F36:  GOTO   2F3E (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
2F3A:  BRA    2EEE
....................  
....................    do  
....................    { 
....................       usb_task(); 
2F3C:  BRA    2F16
....................    } while (usb_state != USB_STATE_POWERED); 
2F3E:  MOVF   30,W
2F40:  SUBLW  02
2F42:  BNZ   2F3C
.................... } 
2F44:  GOTO   2F72 (RETURN)
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
2BF8:  MOVFF  90,95
2BFC:  RCALL  2BB8
2BFE:  MOVF   01,F
2C00:  BZ    2CC4
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
2C02:  MOVF   x90,W
2C04:  MULLW  08
2C06:  MOVF   FF3,W
2C08:  CLRF   x96
2C0A:  MOVWF  x95
2C0C:  MOVLW  04
2C0E:  ADDWF  x95,F
2C10:  MOVLW  00
2C12:  ADDWFC x96,F
2C14:  MOVLW  01
2C16:  ADDWF  x95,W
2C18:  MOVWF  01
2C1A:  MOVLW  00
2C1C:  ADDWFC x96,W
2C1E:  MOVWF  03
2C20:  MOVFF  01,FE9
2C24:  MOVLW  04
2C26:  ADDWF  03,W
2C28:  MOVWF  FEA
2C2A:  MOVFF  91,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
2C2E:  MOVF   x93,W
2C30:  SUBLW  02
2C32:  BNZ   2C62
....................       { 
....................          i = EP_BDxST_I(endpoint); 
2C34:  MOVF   x90,W
2C36:  MULLW  08
2C38:  MOVF   FF3,W
2C3A:  CLRF   x96
2C3C:  MOVWF  x95
2C3E:  MOVLW  04
2C40:  ADDWF  x95,F
2C42:  MOVLW  00
2C44:  ADDWFC x96,F
2C46:  MOVFF  95,FE9
2C4A:  MOVLW  04
2C4C:  ADDWF  x96,W
2C4E:  MOVWF  FEA
2C50:  MOVFF  FEF,94
....................          if (bit_test(i,6)) 
2C54:  BTFSS  x94.6
2C56:  BRA    2C5C
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
2C58:  CLRF   x93
....................          else 
2C5A:  BRA    2C60
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2C5C:  MOVLW  01
2C5E:  MOVWF  x93
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
2C60:  BRA    2C88
2C62:  MOVF   x93,W
2C64:  SUBLW  04
2C66:  BNZ   2C88
....................       { 
....................          i = EP_BDxST_O(endpoint); 
2C68:  MOVF   x90,W
2C6A:  MULLW  08
2C6C:  MOVF   FF3,W
2C6E:  CLRF   x96
2C70:  MOVWF  FE9
2C72:  MOVLW  04
2C74:  ADDWF  x96,W
2C76:  MOVWF  FEA
2C78:  MOVFF  FEF,94
....................          if (bit_test(i,6)) 
2C7C:  BTFSS  x94.6
2C7E:  BRA    2C86
....................             tgl = USB_DTS_DATA1; 
2C80:  MOVLW  01
2C82:  MOVWF  x93
....................          else 
2C84:  BRA    2C88
....................             tgl = USB_DTS_DATA0; 
2C86:  CLRF   x93
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
2C88:  DECFSZ x93,W
2C8A:  BRA    2C92
....................          i=0xC8;  //DATA1, UOWN 
2C8C:  MOVLW  C8
2C8E:  MOVWF  x94
....................       else //if (tgl == USB_DTS_DATA0)  
2C90:  BRA    2C96
....................          i=0x88; //DATA0, UOWN 
2C92:  MOVLW  88
2C94:  MOVWF  x94
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
2C96:  BTFSC  x92.0
2C98:  BSF    x94.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
2C9A:  BTFSC  x92.1
2C9C:  BSF    x94.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
2C9E:  MOVF   x90,W
2CA0:  MULLW  08
2CA2:  MOVF   FF3,W
2CA4:  CLRF   x96
2CA6:  MOVWF  x95
2CA8:  MOVLW  04
2CAA:  ADDWF  x95,F
2CAC:  MOVLW  00
2CAE:  ADDWFC x96,F
2CB0:  MOVFF  95,FE9
2CB4:  MOVLW  04
2CB6:  ADDWF  x96,W
2CB8:  MOVWF  FEA
2CBA:  MOVFF  94,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
2CBE:  MOVLW  01
2CC0:  MOVWF  01
2CC2:  BRA    2CC8
....................    } 
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
2CC4:  MOVLW  00
2CC6:  MOVWF  01
.................... } 
2CC8:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
*
3154:  CLRF   19
3156:  BTFSC  FF2.7
3158:  BSF    19.7
315A:  BCF    FF2.7
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
315C:  MOVFF  7C,95
3160:  RCALL  2BB8
3162:  BTFSC  19.7
3164:  BSF    FF2.7
3166:  MOVF   01,F
3168:  BZ    31EE
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
316A:  MOVF   x7C,W
316C:  MULLW  08
316E:  MOVF   FF3,W
3170:  CLRF   x85
3172:  MOVWF  x84
3174:  MOVLW  04
3176:  ADDWF  x84,F
3178:  MOVLW  00
317A:  ADDWFC x85,F
317C:  MOVLW  02
317E:  ADDWF  x84,W
3180:  MOVWF  01
3182:  MOVLW  00
3184:  ADDWFC x85,W
3186:  MOVWF  03
3188:  MOVFF  01,FE9
318C:  MOVLW  04
318E:  ADDWF  03,W
3190:  MOVWF  FEA
3192:  MOVFF  FEC,83
3196:  MOVF   FED,F
3198:  MOVFF  FEF,82
....................       memcpy(buff_add, ptr, len);      
319C:  MOVFF  83,FEA
31A0:  MOVFF  82,FE9
31A4:  MOVFF  7E,FE2
31A8:  MOVFF  7D,FE1
31AC:  MOVFF  80,02
31B0:  MOVFF  7F,01
31B4:  MOVF   01,F
31B6:  BZ    31BC
31B8:  INCF   02,F
31BA:  BRA    31C0
31BC:  MOVF   02,F
31BE:  BZ    31CC
31C0:  MOVFF  FE6,FEE
31C4:  DECFSZ 01,F
31C6:  BRA    31C0
31C8:  DECFSZ 02,F
31CA:  BRA    31C0
31CC:  CLRF   19
31CE:  BTFSC  FF2.7
31D0:  BSF    19.7
31D2:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
31D4:  MOVFF  7C,90
31D8:  MOVFF  80,92
31DC:  MOVFF  7F,91
31E0:  MOVFF  81,93
31E4:  RCALL  2BF8
31E6:  BTFSC  19.7
31E8:  BSF    FF2.7
31EA:  MOVF   01,W
31EC:  BRA    31F2
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
31EE:  MOVLW  00
31F0:  MOVWF  01
.................... } 
31F2:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
2B00:  MOVF   x90,W
2B02:  MULLW  08
2B04:  MOVF   FF3,W
2B06:  CLRF   x96
2B08:  MOVWF  FE9
2B0A:  MOVLW  04
2B0C:  ADDWF  x96,W
2B0E:  MOVWF  FEA
2B10:  MOVFF  FEF,92
....................    if (tgl == USB_DTS_TOGGLE)  
2B14:  MOVF   x91,W
2B16:  SUBLW  02
2B18:  BNZ   2B26
....................    { 
....................       if (bit_test(i,6)) 
2B1A:  BTFSS  x92.6
2B1C:  BRA    2B22
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
2B1E:  CLRF   x91
....................       else 
2B20:  BRA    2B26
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2B22:  MOVLW  01
2B24:  MOVWF  x91
....................    } 
....................    if (tgl == USB_DTS_STALL)  
2B26:  MOVF   x91,W
2B28:  SUBLW  03
2B2A:  BNZ   2B52
....................    { 
....................       i = 0x84; 
2B2C:  MOVLW  84
2B2E:  MOVWF  x92
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
2B30:  MOVF   x90,W
2B32:  MULLW  08
2B34:  MOVF   FF3,W
2B36:  CLRF   x96
2B38:  MOVWF  x95
2B3A:  MOVLW  04
2B3C:  ADDWF  x95,F
2B3E:  MOVLW  00
2B40:  ADDWFC x96,F
2B42:  MOVFF  95,FE9
2B46:  MOVLW  04
2B48:  ADDWF  x96,W
2B4A:  MOVWF  FEA
2B4C:  MOVLW  84
2B4E:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
2B50:  BRA    2B60
2B52:  DECFSZ x91,W
2B54:  BRA    2B5C
....................       i = 0xC8;  //DATA1, UOWN 
2B56:  MOVLW  C8
2B58:  MOVWF  x92
....................    else //if (tgl == USB_DTS_DATA0)  
2B5A:  BRA    2B60
....................       i = 0x88; //DATA0, UOWN 
2B5C:  MOVLW  88
2B5E:  MOVWF  x92
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
2B60:  BCF    FD8.0
2B62:  RLCF   x90,W
2B64:  CLRF   03
2B66:  CALL   212A
2B6A:  TBLRD*+
2B6C:  MOVFF  FF5,03
2B70:  MOVWF  x93
2B72:  MOVFF  03,94
....................    EP_BDxCNT_O(endpoint) = len; 
2B76:  MOVF   x90,W
2B78:  MULLW  08
2B7A:  MOVF   FF3,W
2B7C:  CLRF   x96
2B7E:  MOVWF  x95
2B80:  MOVLW  01
2B82:  ADDWF  x95,W
2B84:  MOVWF  01
2B86:  MOVLW  00
2B88:  ADDWFC x96,W
2B8A:  MOVWF  03
2B8C:  MOVFF  01,FE9
2B90:  MOVLW  04
2B92:  ADDWF  03,W
2B94:  MOVWF  FEA
2B96:  MOVFF  93,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
2B9A:  BTFSC  x94.0
2B9C:  BSF    x92.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
2B9E:  BTFSC  x94.1
2BA0:  BSF    x92.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
2BA2:  MOVF   x90,W
2BA4:  MULLW  08
2BA6:  MOVF   FF3,W
2BA8:  CLRF   x96
2BAA:  MOVWF  FE9
2BAC:  MOVLW  04
2BAE:  ADDWF  x96,W
2BB0:  MOVWF  FEA
2BB2:  MOVFF  92,FEF
.................... } 
2BB6:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
29C8:  BCF    x91.0
29CA:  BTFSC  x90.7
29CC:  BSF    x91.0
....................    endpoint &= 0x7F; 
29CE:  BCF    x90.7
....................     
....................    if (direction)  
29D0:  BTFSS  x91.0
29D2:  BRA    29F6
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
29D4:  MOVF   x90,W
29D6:  MULLW  08
29D8:  MOVF   FF3,W
29DA:  CLRF   x93
29DC:  MOVWF  x92
29DE:  MOVLW  04
29E0:  ADDWF  x92,F
29E2:  MOVLW  00
29E4:  ADDWFC x93,F
29E6:  MOVFF  92,FE9
29EA:  MOVLW  04
29EC:  ADDWF  x93,W
29EE:  MOVWF  FEA
29F0:  MOVLW  84
29F2:  MOVWF  FEF
....................    } 
....................    else  
29F4:  BRA    2A0A
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
29F6:  MOVF   x90,W
29F8:  MULLW  08
29FA:  MOVF   FF3,W
29FC:  CLRF   x93
29FE:  MOVWF  FE9
2A00:  MOVLW  04
2A02:  ADDWF  x93,W
2A04:  MOVWF  FEA
2A06:  MOVLW  84
2A08:  MOVWF  FEF
....................    } 
.................... } 
2A0A:  GOTO   2A94 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
2984:  BCF    x91.0
2986:  BTFSC  x90.7
2988:  BSF    x91.0
....................    endpoint &= 0x7F; 
298A:  BCF    x90.7
....................     
....................    if (direction)  
298C:  BTFSS  x91.0
298E:  BRA    29B2
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
2990:  MOVF   x90,W
2992:  MULLW  08
2994:  MOVF   FF3,W
2996:  CLRF   x93
2998:  MOVWF  x92
299A:  MOVLW  04
299C:  ADDWF  x92,F
299E:  MOVLW  00
29A0:  ADDWFC x93,F
29A2:  MOVFF  92,FE9
29A6:  MOVLW  04
29A8:  ADDWF  x93,W
29AA:  MOVWF  FEA
29AC:  MOVLW  88
29AE:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
29B0:  BRA    29C4
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
29B2:  MOVF   x90,W
29B4:  MULLW  08
29B6:  MOVF   FF3,W
29B8:  CLRF   x93
29BA:  MOVWF  FE9
29BC:  MOVLW  04
29BE:  ADDWF  x93,W
29C0:  MOVWF  FEA
29C2:  CLRF   FEF
....................    } 
.................... } 
29C4:  GOTO   2A88 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
2A0E:  BCF    x91.0
2A10:  BTFSC  x90.7
2A12:  BSF    x91.0
....................    endpoint &= 0x7F; 
2A14:  BCF    x90.7
....................     
....................    if (direction)  
2A16:  BTFSS  x91.0
2A18:  BRA    2A3C
....................    { 
....................       st=EP_BDxST_I(endpoint); 
2A1A:  MOVF   x90,W
2A1C:  MULLW  08
2A1E:  MOVF   FF3,W
2A20:  CLRF   x94
2A22:  MOVWF  x93
2A24:  MOVLW  04
2A26:  ADDWF  x93,F
2A28:  MOVLW  00
2A2A:  ADDWFC x94,F
2A2C:  MOVFF  93,FE9
2A30:  MOVLW  04
2A32:  ADDWF  x94,W
2A34:  MOVWF  FEA
2A36:  MOVFF  FEF,92
....................    } 
....................    else  
2A3A:  BRA    2A50
....................    { 
....................       st=EP_BDxST_O(endpoint); 
2A3C:  MOVF   x90,W
2A3E:  MULLW  08
2A40:  MOVF   FF3,W
2A42:  CLRF   x94
2A44:  MOVWF  FE9
2A46:  MOVLW  04
2A48:  ADDWF  x94,W
2A4A:  MOVWF  FEA
2A4C:  MOVFF  FEF,92
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
2A50:  BTFSS  x92.7
2A52:  BRA    2A58
2A54:  BTFSC  x92.2
2A56:  BRA    2A5C
2A58:  MOVLW  00
2A5A:  BRA    2A5E
2A5C:  MOVLW  01
2A5E:  MOVWF  01
.................... } 
2A60:  GOTO   2AA8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
2CD0:  MOVFF  91,F6E
....................     
....................    if (address)  
2CD4:  MOVF   x91,F
2CD6:  BZ    2CDE
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
2CD8:  MOVLW  04
2CDA:  MOVWF  30
....................    } 
....................    else  
2CDC:  BRA    2CE2
....................    { 
....................       usb_state = USB_STATE_POWERED; 
2CDE:  MOVLW  02
2CE0:  MOVWF  30
....................    } 
.................... } 
2CE2:  GOTO   2CF0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
26DA:  MOVF   x90,F
26DC:  BNZ   26E6
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
26DE:  MOVLW  04
26E0:  MOVWF  30
....................       usb_disable_endpoints(); 
26E2:  RCALL  24FC
....................    } 
....................    else  
26E4:  BRA    2848
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
26E6:  MOVLW  05
26E8:  MOVWF  30
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
26EA:  MOVLW  04
26EC:  MOVWF  x93
26EE:  MOVLW  98
26F0:  MOVWF  x92
....................       for (en=1; en<USB_NUM_UEP; en++)  
26F2:  MOVLW  01
26F4:  MOVWF  x91
26F6:  MOVF   x91,W
26F8:  SUBLW  0F
26FA:  BTFSS  FD8.0
26FC:  BRA    2848
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
26FE:  MOVFF  91,99
2702:  RCALL  24B0
....................          new_uep = 0; 
2704:  CLRF   x94
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
2706:  CLRF   03
2708:  MOVF   x91,W
270A:  RCALL  20DA
270C:  SUBLW  FF
270E:  BZ    27AA
....................          { 
....................             new_uep = 0x04; 
2710:  MOVLW  04
2712:  MOVWF  x94
....................             len = usb_ep_rx_size[en]; 
2714:  BCF    FD8.0
2716:  RLCF   x91,W
2718:  CLRF   03
271A:  RCALL  212A
271C:  TBLRD*+
271E:  MOVFF  FF5,03
2722:  MOVWF  x95
2724:  MOVFF  03,96
....................             EP_BDxCNT_O(en) = len; 
2728:  MOVF   x91,W
272A:  MULLW  08
272C:  MOVF   FF3,W
272E:  CLRF   x99
2730:  MOVWF  x98
2732:  MOVLW  01
2734:  ADDWF  x98,W
2736:  MOVWF  01
2738:  MOVLW  00
273A:  ADDWFC x99,W
273C:  MOVWF  03
273E:  MOVFF  01,FE9
2742:  MOVLW  04
2744:  ADDWF  03,W
2746:  MOVWF  FEA
2748:  MOVFF  95,FEF
....................             EP_BDxADR_O(en) = addy; 
274C:  MOVF   x91,W
274E:  MULLW  08
2750:  MOVF   FF3,W
2752:  CLRF   x99
2754:  MOVWF  x98
2756:  MOVLW  02
2758:  ADDWF  x98,W
275A:  MOVWF  01
275C:  MOVLW  00
275E:  ADDWFC x99,W
2760:  MOVWF  03
2762:  MOVFF  01,FE9
2766:  MOVLW  04
2768:  ADDWF  03,W
276A:  MOVWF  FEA
276C:  MOVFF  93,FEC
2770:  MOVF   FED,F
2772:  MOVFF  92,FEF
....................             addy += usb_ep_rx_size[en]; 
2776:  BCF    FD8.0
2778:  RLCF   x91,W
277A:  CLRF   03
277C:  RCALL  212A
277E:  TBLRD*+
2780:  MOVFF  FF5,03
2784:  ADDWF  x92,F
2786:  MOVF   03,W
2788:  ADDWFC x93,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
278A:  MOVLW  88
278C:  MOVWF  x97
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
278E:  BTFSC  x96.0
2790:  BSF    x97.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
2792:  BTFSC  x96.1
2794:  BSF    x97.1
....................             EP_BDxST_O(en) = i; 
2796:  MOVF   x91,W
2798:  MULLW  08
279A:  MOVF   FF3,W
279C:  CLRF   x99
279E:  MOVWF  FE9
27A0:  MOVLW  04
27A2:  ADDWF  x99,W
27A4:  MOVWF  FEA
27A6:  MOVFF  97,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
27AA:  CLRF   03
27AC:  MOVF   x91,W
27AE:  RCALL  20BA
27B0:  SUBLW  FF
27B2:  BZ    281C
....................          { 
....................             new_uep |= 0x02; 
27B4:  BSF    x94.1
....................             EP_BDxADR_I(en) = addy; 
27B6:  MOVF   x91,W
27B8:  MULLW  08
27BA:  MOVF   FF3,W
27BC:  CLRF   x99
27BE:  MOVWF  x98
27C0:  MOVLW  04
27C2:  ADDWF  x98,F
27C4:  MOVLW  00
27C6:  ADDWFC x99,F
27C8:  MOVLW  02
27CA:  ADDWF  x98,W
27CC:  MOVWF  01
27CE:  MOVLW  00
27D0:  ADDWFC x99,W
27D2:  MOVWF  03
27D4:  MOVFF  01,FE9
27D8:  MOVLW  04
27DA:  ADDWF  03,W
27DC:  MOVWF  FEA
27DE:  MOVFF  93,FEC
27E2:  MOVF   FED,F
27E4:  MOVFF  92,FEF
....................             addy += usb_ep_tx_size[en]; 
27E8:  BCF    FD8.0
27EA:  RLCF   x91,W
27EC:  CLRF   03
27EE:  RCALL  20FA
27F0:  TBLRD*+
27F2:  MOVFF  FF5,03
27F6:  ADDWF  x92,F
27F8:  MOVF   03,W
27FA:  ADDWFC x93,F
....................             EP_BDxST_I(en) = 0x40; 
27FC:  MOVF   x91,W
27FE:  MULLW  08
2800:  MOVF   FF3,W
2802:  CLRF   x99
2804:  MOVWF  x98
2806:  MOVLW  04
2808:  ADDWF  x98,F
280A:  MOVLW  00
280C:  ADDWFC x99,F
280E:  MOVFF  98,FE9
2812:  MOVLW  04
2814:  ADDWF  x99,W
2816:  MOVWF  FEA
2818:  MOVLW  40
281A:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
281C:  MOVF   x94,W
281E:  SUBLW  06
2820:  BNZ   2826
2822:  MOVLW  0E
2824:  MOVWF  x94
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
2826:  CLRF   03
2828:  MOVF   x91,W
282A:  RCALL  20BA
282C:  SUBLW  01
282E:  BTFSS  FD8.2
2830:  BSF    x94.4
....................           
....................          UEP(en) = new_uep; 
2832:  CLRF   03
2834:  MOVF   x91,W
2836:  ADDLW  70
2838:  MOVWF  FE9
283A:  MOVLW  0F
283C:  ADDWFC 03,W
283E:  MOVWF  FEA
2840:  MOVFF  94,FEF
....................       } 
2844:  INCF   x91,F
2846:  BRA    26F6
....................    } 
.................... } 
2848:  GOTO   28E2 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
24B0:  CLRF   03
24B2:  MOVF   x99,W
24B4:  ADDLW  70
24B6:  MOVWF  FE9
24B8:  MOVLW  0F
24BA:  ADDWFC 03,W
24BC:  MOVWF  FEA
24BE:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
24C0:  MOVFF  99,9A
24C4:  RCALL  246E
24C6:  MOVF   01,F
24C8:  BZ    24FA
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
24CA:  MOVF   x99,W
24CC:  MULLW  08
24CE:  MOVF   FF3,W
24D0:  CLRF   x9B
24D2:  MOVWF  FE9
24D4:  MOVLW  04
24D6:  ADDWF  x9B,W
24D8:  MOVWF  FEA
24DA:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
24DC:  MOVF   x99,W
24DE:  MULLW  08
24E0:  MOVF   FF3,W
24E2:  CLRF   x9B
24E4:  MOVWF  x9A
24E6:  MOVLW  04
24E8:  ADDWF  x9A,F
24EA:  MOVLW  00
24EC:  ADDWFC x9B,F
24EE:  MOVFF  9A,FE9
24F2:  MOVLW  04
24F4:  ADDWF  x9B,W
24F6:  MOVWF  FEA
24F8:  CLRF   FEF
....................    } 
.................... } 
24FA:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
24FC:  MOVLW  01
24FE:  MOVWF  x98
2500:  MOVF   x98,W
2502:  SUBLW  0F
2504:  BNC   2510
....................       usb_disable_endpoint(i); 
2506:  MOVFF  98,99
250A:  RCALL  24B0
250C:  INCF   x98,F
250E:  BRA    2500
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
2510:  RETURN 0
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
2538:  BCF    F68.3
.................... } 
253A:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
2E4C:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
2E4E:  MOVF   30,F
2E50:  BNZ   2E54
2E52:  BRA    2EC6
....................    if (UIR)  
2E54:  MOVF   F68,F
2E56:  BZ    2EC6
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
2E58:  BTFSS  F68.2
2E5A:  BRA    2E64
2E5C:  BTFSS  F69.2
2E5E:  BRA    2E64
2E60:  GOTO   2428
....................  
....................       if (UCON_SUSPND) return; 
2E64:  BTFSS  F6D.1
2E66:  BRA    2E6A
2E68:  BRA    2EC6
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
2E6A:  BTFSS  F68.5
2E6C:  BRA    2E76
2E6E:  BTFSS  F69.5
2E70:  BRA    2E76
2E72:  GOTO   2458
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
2E76:  BTFSS  F68.1
2E78:  BRA    2E82
2E7A:  BTFSS  F69.1
2E7C:  BRA    2E82
2E7E:  GOTO   2466
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
2E82:  BTFSS  F68.0
2E84:  BRA    2E8E
2E86:  BTFSS  F69.0
2E88:  BRA    2E8E
2E8A:  GOTO   253C
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
2E8E:  BTFSS  F68.4
2E90:  BRA    2E9A
2E92:  BTFSS  F69.4
2E94:  BRA    2E9A
2E96:  GOTO   2566
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
2E9A:  BTFSS  F68.6
2E9C:  BRA    2EA6
2E9E:  BTFSS  F69.6
2EA0:  BRA    2EA6
2EA2:  GOTO   2570
....................  
....................       TRNAttempts = 0; 
2EA6:  CLRF   x8D
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
2EA8:  BTFSS  F68.3
2EAA:  BRA    2EBC
2EAC:  BTFSS  F69.3
2EAE:  BRA    2EBC
....................          { 
....................             USTATCopy = U1STAT; 
2EB0:  MOVFF  F6C,2F
....................             usb_clear_trn(); 
2EB4:  CALL   2538
....................             usb_isr_tok_dne(); 
2EB8:  BRA    2D0A
....................          } 
....................          else 
2EBA:  BRA    2EBE
....................             break; 
2EBC:  BRA    2EC6
....................       } while (TRNAttempts++ < 4); 
2EBE:  MOVF   x8D,W
2EC0:  INCF   x8D,F
2EC2:  SUBLW  03
2EC4:  BC    2EA8
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
2EC6:  GOTO   206C
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
2570:  BCF    F68.6
.................... } 
2572:  GOTO   2EA6 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
253C:  CLRF   F6A
....................    UIR = 0; 
253E:  CLRF   F68
....................    UEIE = 0x9F; 
2540:  MOVLW  9F
2542:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
2544:  MOVLW  3D
2546:  MOVWF  F69
....................  
....................    UADDR = 0; 
2548:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
254A:  RCALL  24FC
....................     
....................    usb_token_reset(); 
254C:  RCALL  2512
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
254E:  MOVLW  16
2550:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
2552:  BTFSS  F68.3
2554:  BRA    255A
....................       usb_clear_trn(); 
2556:  RCALL  2538
....................    } 
2558:  BRA    2552
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
255A:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
255C:  RCALL  2438
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
255E:  MOVLW  03
2560:  MOVWF  30
.................... } 
2562:  GOTO   2E8E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
2438:  MOVLW  40
243A:  MOVLB  4
243C:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
243E:  MOVLW  04
2440:  MOVWF  x03
2442:  MOVLW  18
2444:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
2446:  MOVLW  88
2448:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
244A:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
244C:  MOVLW  04
244E:  MOVWF  x07
2450:  MOVLW  58
2452:  MOVWF  x06
.................... } 
2454:  MOVLB  0
2456:  RETURN 0
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
2466:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
2468:  BCF    F68.1
.................... } 
246A:  GOTO   2E82 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
2566:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
2568:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
256A:  BSF    F6D.1
.................... } 
256C:  GOTO   2E9A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
2428:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
242A:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
242C:  BTFSS  F68.2
242E:  BRA    2434
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
2430:  BCF    F68.2
....................    } 
2432:  BRA    242C
.................... } 
2434:  GOTO   2E64 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
2458:  BTFSS  F70.0
245A:  BRA    2460
....................    { 
....................       usb_init_ep0_setup(); 
245C:  RCALL  2438
....................       bit_clear(UEP(0), 0); 
245E:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
2460:  BCF    F68.5
.................... } 
2462:  GOTO   2E76 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
2576:  MOVFF  93,31
257A:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
257C:  SETF   31
257E:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
2D0A:  RRCF   2F,W
2D0C:  MOVWF  x8E
2D0E:  RRCF   x8E,F
2D10:  RRCF   x8E,F
2D12:  MOVLW  1F
2D14:  ANDWF  x8E,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
2D16:  MOVF   2F,F
2D18:  BNZ   2D9C
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
2D1A:  MOVLB  4
2D1C:  MOVF   x00,W
2D1E:  ANDLW  3C
2D20:  MOVLB  0
2D22:  MOVWF  x8F
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
2D24:  MOVLW  43
2D26:  MOVLB  4
2D28:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
2D2A:  MOVLB  0
2D2C:  MOVF   x8F,W
2D2E:  SUBLW  34
2D30:  BNZ   2D6E
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
2D32:  MOVLB  4
2D34:  MOVF   x04,W
2D36:  ANDLW  80
2D38:  BZ    2D3C
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
2D3A:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
2D3C:  MOVLB  0
2D3E:  BRA    2ACE
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
2D40:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
2D42:  INCFSZ 31,W
2D44:  BRA    2D50
....................             usb_flush_out(0, USB_DTS_STALL); 
2D46:  CLRF   x90
2D48:  MOVLW  03
2D4A:  MOVWF  x91
2D4C:  RCALL  2B00
....................          else  
2D4E:  BRA    2D6C
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
2D50:  CLRF   x90
2D52:  MOVLW  02
2D54:  MOVWF  x91
2D56:  RCALL  2B00
....................             if (__setup_0_tx_size != 0xFE) 
2D58:  MOVF   31,W
2D5A:  SUBLW  FE
2D5C:  BZ    2D6C
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
2D5E:  CLRF   x90
2D60:  CLRF   x92
2D62:  MOVFF  31,91
2D66:  MOVLW  04
2D68:  MOVWF  x93
2D6A:  RCALL  2BF8
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
2D6C:  BRA    2D9A
2D6E:  MOVF   x8F,W
2D70:  SUBLW  04
2D72:  BNZ   2D9A
....................       { 
....................          usb_isr_tok_out_dne(0); 
2D74:  CLRF   x90
2D76:  RCALL  2CCA
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
2D78:  CLRF   x90
2D7A:  MOVLW  02
2D7C:  MOVWF  x91
2D7E:  RCALL  2B00
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
2D80:  MOVF   31,W
2D82:  SUBLW  FE
2D84:  BZ    2D9A
2D86:  INCFSZ 31,W
2D88:  BRA    2D8C
2D8A:  BRA    2D9A
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
2D8C:  CLRF   x90
2D8E:  CLRF   x92
2D90:  MOVFF  31,91
2D94:  MOVLW  01
2D96:  MOVWF  x93
2D98:  RCALL  2BF8
....................          } 
....................       } 
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
2D9A:  BRA    2E48
2D9C:  MOVF   2F,W
2D9E:  SUBLW  04
2DA0:  BNZ   2DC6
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
2DA2:  MOVLW  43
2DA4:  MOVLB  4
2DA6:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
2DA8:  SETF   31
....................       usb_isr_tok_in_dne(0); 
2DAA:  MOVLB  0
2DAC:  CLRF   x90
2DAE:  RCALL  2CF4
....................       if (__setup_0_tx_size!=0xFF) 
2DB0:  INCFSZ 31,W
2DB2:  BRA    2DB6
2DB4:  BRA    2DC4
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
2DB6:  CLRF   x90
2DB8:  CLRF   x92
2DBA:  MOVFF  31,91
2DBE:  MOVLW  02
2DC0:  MOVWF  x93
2DC2:  RCALL  2BF8
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
2DC4:  BRA    2E48
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
2DC6:  BTFSC  2F.2
2DC8:  BRA    2E00
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
2DCA:  MOVF   x8E,W
2DCC:  MULLW  08
2DCE:  MOVF   FF3,W
2DD0:  CLRF   x91
2DD2:  MOVWF  01
2DD4:  MOVLW  04
2DD6:  ADDWF  x91,W
2DD8:  MOVWF  03
2DDA:  MOVF   x8E,W
2DDC:  MULLW  08
2DDE:  MOVF   FF3,W
2DE0:  CLRF   x95
2DE2:  MOVWF  FE9
2DE4:  MOVLW  04
2DE6:  ADDWF  x95,W
2DE8:  MOVWF  FEA
2DEA:  MOVF   FEF,W
2DEC:  ANDLW  43
2DEE:  MOVFF  03,FEA
2DF2:  MOVFF  01,FE9
2DF6:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
2DF8:  MOVFF  8E,90
2DFC:  RCALL  2CCA
....................       } 
....................       else  
2DFE:  BRA    2E48
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
2E00:  MOVF   x8E,W
2E02:  MULLW  08
2E04:  MOVF   FF3,W
2E06:  CLRF   x91
2E08:  MOVWF  x90
2E0A:  MOVLW  04
2E0C:  ADDWF  x90,F
2E0E:  MOVLW  00
2E10:  ADDWFC x91,F
2E12:  MOVLW  04
2E14:  ADDWF  x91,W
2E16:  MOVWF  03
2E18:  MOVF   x8E,W
2E1A:  MULLW  08
2E1C:  MOVF   FF3,W
2E1E:  CLRF   x95
2E20:  MOVWF  x94
2E22:  MOVLW  04
2E24:  ADDWF  x94,F
2E26:  MOVLW  00
2E28:  ADDWFC x95,F
2E2A:  MOVFF  94,FE9
2E2E:  MOVLW  04
2E30:  ADDWF  x95,W
2E32:  MOVWF  FEA
2E34:  MOVF   FEF,W
2E36:  ANDLW  43
2E38:  MOVFF  03,FEA
2E3C:  MOVFF  90,FE9
2E40:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
2E42:  MOVFF  8E,90
2E46:  RCALL  2CF4
....................       } 
....................    } 
.................... } 
2E48:  GOTO   2EBA (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include "usb\pic24_usb.c" 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
2512:  CLRF   x8E
2514:  MOVF   x8E,W
2516:  SUBLW  01
2518:  BNC   252E
....................       USB_Interface[i] = 0;   //reset each interface to default 
251A:  CLRF   03
251C:  MOVF   x8E,W
251E:  ADDLW  35
2520:  MOVWF  FE9
2522:  MOVLW  00
2524:  ADDWFC 03,W
2526:  MOVWF  FEA
2528:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
252A:  INCF   x8E,F
252C:  BRA    2514
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
252E:  CLRF   2C
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
2530:  MOVLW  01
2532:  MOVWF  2D
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
2534:  CLRF   2B
.................... } 
2536:  RETURN 0
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
246E:  BCF    x9B.0
2470:  BTFSC  x9A.7
2472:  BSF    x9B.0
....................     
....................    endpoint &= 0x7F; 
2474:  BCF    x9A.7
....................     
....................    if (endpoint > 16) 
2476:  MOVF   x9A,W
2478:  SUBLW  10
247A:  BC    2482
....................       return(FALSE); 
247C:  MOVLW  00
247E:  MOVWF  01
2480:  BRA    24AE
....................     
....................    if (direction) { //IN 
2482:  BTFSS  x9B.0
2484:  BRA    249C
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
2486:  CLRF   03
2488:  MOVF   x9A,W
248A:  RCALL  20BA
248C:  SUBLW  FF
248E:  BNZ   2494
2490:  MOVLW  00
2492:  BRA    2496
2494:  MOVLW  01
2496:  MOVWF  01
2498:  BRA    24AE
....................    } 
....................    else {   //OUT 
249A:  BRA    24AE
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
249C:  CLRF   03
249E:  MOVF   x9A,W
24A0:  RCALL  20DA
24A2:  SUBLW  FF
24A4:  BNZ   24AA
24A6:  MOVLW  00
24A8:  BRA    24AC
24AA:  MOVLW  01
24AC:  MOVWF  01
....................    } 
.................... } 
24AE:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
2CF4:  MOVF   x90,F
2CF6:  BNZ   2D08
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
2CF8:  DECFSZ 2B,W
2CFA:  BRA    2D00
2CFC:  RCALL  2580
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
2CFE:  BRA    2D08
2D00:  MOVF   2B,W
2D02:  SUBLW  02
2D04:  BNZ   2D08
2D06:  BRA    2CE6
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
2D08:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2CCA:  MOVF   x90,F
2CCC:  BNZ   2CCE
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
2CCE:  RETURN 0
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
2ACE:  CLRF   2B
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
2AD0:  MOVLB  4
2AD2:  MOVF   x18,W
2AD4:  ANDLW  7F
2AD6:  XORLW  00
2AD8:  MOVLB  0
2ADA:  BZ    2AEA
2ADC:  XORLW  01
2ADE:  BZ    2AEE
2AE0:  XORLW  03
2AE2:  BZ    2AF2
2AE4:  XORLW  23
2AE6:  BZ    2AF6
2AE8:  BRA    2AFA
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
2AEA:  BRA    284C
....................          break; 
2AEC:  BRA    2AFC
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
2AEE:  BRA    28F0
....................          break; 
2AF0:  BRA    2AFC
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
2AF2:  BRA    2A64
....................          break; 
2AF4:  BRA    2AFC
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
2AF6:  BRA    2AC2
....................          break; 
2AF8:  BRA    2AFC
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
2AFA:  RCALL  257C
....................          break; 
....................    } 
.................... } 
2AFC:  GOTO   2D40 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
284C:  MOVLB  4
284E:  MOVF   x19,W
2850:  XORLW  00
2852:  MOVLB  0
2854:  BZ    2870
2856:  XORLW  01
2858:  BZ    2882
285A:  XORLW  02
285C:  BZ    289A
285E:  XORLW  06
2860:  BZ    28B0
2862:  XORLW  03
2864:  BZ    28BE
2866:  XORLW  0E
2868:  BZ    28C2
286A:  XORLW  01
286C:  BZ    28CE
286E:  BRA    28EA
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
2870:  MOVFF  2D,458
....................             usb_ep0_tx_buffer[1]=0; 
2874:  MOVLB  4
2876:  CLRF   x59
....................             usb_request_send_response(2); 
2878:  MOVLW  02
287A:  MOVLB  0
287C:  MOVWF  x93
287E:  RCALL  2576
....................             break; 
2880:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
2882:  MOVLB  4
2884:  DECFSZ x1A,W
2886:  BRA    2894
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
2888:  MOVLW  01
288A:  ANDWF  2D,F
....................                usb_put_0len_0(); 
288C:  MOVLB  0
288E:  CLRF   x93
2890:  RCALL  2576
....................             } 
....................             else 
2892:  BRA    2898
....................                usb_request_stall(); 
2894:  MOVLB  0
2896:  RCALL  257C
....................             break; 
2898:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
289A:  MOVLB  4
289C:  DECFSZ x1A,W
289E:  BRA    28AA
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
28A0:  BSF    2D.1
....................                usb_put_0len_0(); 
28A2:  MOVLB  0
28A4:  CLRF   x93
28A6:  RCALL  2576
....................             } 
....................             else 
28A8:  BRA    28AE
....................                usb_request_stall(); 
28AA:  MOVLB  0
28AC:  RCALL  257C
....................             break; 
28AE:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
28B0:  MOVLW  02
28B2:  MOVWF  2B
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
28B4:  MOVFF  41A,32
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
28B8:  CLRF   x93
28BA:  RCALL  2576
....................             break; 
28BC:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
28BE:  RCALL  260E
....................             break; 
28C0:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
28C2:  MOVFF  2C,458
....................             usb_request_send_response(1); 
28C6:  MOVLW  01
28C8:  MOVWF  x93
28CA:  RCALL  2576
....................             break; 
28CC:  BRA    28EC
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
28CE:  MOVLB  4
28D0:  MOVF   x1A,W
28D2:  SUBLW  01
28D4:  BNC   28E6
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
28D6:  MOVFF  41A,2C
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
28DA:  MOVFF  41A,90
28DE:  MOVLB  0
28E0:  BRA    26DA
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
28E2:  CLRF   x93
28E4:  RCALL  2576
....................             } 
....................             break; 
28E6:  MOVLB  0
28E8:  BRA    28EC
....................  
....................       default: 
....................             usb_request_stall(); 
28EA:  RCALL  257C
....................             break; 
....................    } 
.................... } 
28EC:  GOTO   2AFC (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
28F0:  MOVFF  2C,90
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
28F4:  MOVLB  4
28F6:  MOVF   x19,W
28F8:  XORLW  00
28FA:  MOVLB  0
28FC:  BZ    290C
28FE:  XORLW  0A
2900:  BZ    291C
2902:  XORLW  01
2904:  BZ    2956
2906:  XORLW  0D
2908:  BZ    297A
290A:  BRA    297E
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
290C:  MOVLB  4
290E:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0; 
2910:  CLRF   x59
....................             usb_request_send_response(2); 
2912:  MOVLW  02
2914:  MOVLB  0
2916:  MOVWF  x93
2918:  RCALL  2576
....................             break; 
291A:  BRA    2980
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
291C:  MOVF   x90,F
291E:  BZ    2952
2920:  MOVLW  01
2922:  SUBWF  x90,W
2924:  CLRF   03
2926:  RCALL  2258
2928:  MOVWF  01
292A:  MOVLB  4
292C:  SUBWF  x1C,W
292E:  BTFSS  FD8.0
2930:  BRA    2936
2932:  MOVLB  0
2934:  BRA    2952
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
2936:  CLRF   03
2938:  MOVF   x1C,W
293A:  ADDLW  35
293C:  MOVWF  FE9
293E:  MOVLW  00
2940:  ADDWFC 03,W
2942:  MOVWF  FEA
2944:  MOVFF  FEF,458
....................                usb_request_send_response(1);; //send byte back 
2948:  MOVLW  01
294A:  MOVLB  0
294C:  MOVWF  x93
294E:  RCALL  2576
....................             } 
....................             else 
2950:  BRA    2954
....................                usb_request_stall(); 
2952:  RCALL  257C
....................             break; 
2954:  BRA    2980
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
2956:  MOVF   x90,F
2958:  BZ    2976
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
295A:  CLRF   03
295C:  MOVLB  4
295E:  MOVF   x1C,W
2960:  ADDLW  35
2962:  MOVWF  FE9
2964:  MOVLW  00
2966:  ADDWFC 03,W
2968:  MOVWF  FEA
296A:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
296E:  MOVLB  0
2970:  CLRF   x93
2972:  RCALL  2576
....................             } 
....................             else 
2974:  BRA    2978
....................                usb_request_stall(); 
2976:  RCALL  257C
....................             break; 
2978:  BRA    2980
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
297A:  RCALL  260E
....................             break; 
297C:  BRA    2980
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
297E:  RCALL  257C
....................             break; 
....................    } 
.................... } 
2980:  GOTO   2AFC (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
2A64:  MOVFF  41C,9A
2A68:  RCALL  246E
2A6A:  MOVF   01,F
2A6C:  BZ    2ABE
....................       switch(usb_ep0_rx_buffer[1]) { 
2A6E:  MOVLB  4
2A70:  MOVF   x19,W
2A72:  XORLW  01
2A74:  MOVLB  0
2A76:  BZ    2A82
2A78:  XORLW  02
2A7A:  BZ    2A8E
2A7C:  XORLW  03
2A7E:  BZ    2A9A
2A80:  BRA    2ABC
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
2A82:  MOVFF  41C,90
2A86:  BRA    2984
....................                usb_put_0len_0(); 
2A88:  CLRF   x93
2A8A:  RCALL  2576
....................                break; 
2A8C:  BRA    2ABE
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
2A8E:  MOVFF  41C,90
2A92:  BRA    29C8
....................                      usb_put_0len_0(); 
2A94:  CLRF   x93
2A96:  RCALL  2576
....................                      break; 
2A98:  BRA    2ABE
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
2A9A:  MOVLB  4
2A9C:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0; 
2A9E:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
2AA0:  MOVFF  41C,90
2AA4:  MOVLB  0
2AA6:  BRA    2A0E
2AA8:  MOVF   01,F
2AAA:  BZ    2AB4
....................                   usb_ep0_tx_buffer[0]=1; 
2AAC:  MOVLW  01
2AAE:  MOVLB  4
2AB0:  MOVWF  x58
2AB2:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
2AB4:  MOVLW  02
2AB6:  MOVWF  x93
2AB8:  RCALL  2576
....................                break; 
2ABA:  BRA    2ABE
....................  
....................          default: 
....................             usb_request_stall(); 
2ABC:  RCALL  257C
....................             break; 
....................       } 
....................    } 
.................... } 
2ABE:  GOTO   2AFC (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
2AC2:  MOVLB  4
2AC4:  MOVF   x19,W
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
2AC6:  MOVLB  0
2AC8:  RCALL  257C
....................             break; 
....................    } 
.................... } 
2ACA:  GOTO   2AFC (RETURN)
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
260E:  CLRF   33
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
2610:  CLRF   2E
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
2612:  MOVLB  4
2614:  MOVF   x1B,W
2616:  XORLW  01
2618:  MOVLB  0
261A:  BZ    262E
261C:  XORLW  03
261E:  BZ    2638
2620:  XORLW  01
2622:  BZ    263E
2624:  XORLW  22
2626:  BZ    2658
2628:  XORLW  03
262A:  BZ    2682
262C:  BRA    26BC
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
262E:  MOVLW  12
2630:  MOVWF  34
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
2632:  MOVLW  03
2634:  MOVWF  2E
....................             break; 
2636:  BRA    26C0
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
2638:  MOVLW  42
263A:  MOVWF  34
....................             break; 
263C:  BRA    26C0
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
263E:  MOVLW  02
2640:  MOVWF  2E
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
2642:  CLRF   03
2644:  MOVLB  4
2646:  MOVF   x1A,W
2648:  MOVLB  0
264A:  RCALL  22A0
264C:  MOVWF  33
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
264E:  CLRF   03
2650:  MOVF   33,W
2652:  RCALL  22B4
2654:  MOVWF  34
....................             break; 
2656:  BRA    26C0
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
2658:  BCF    FD8.0
265A:  MOVLB  4
265C:  RLCF   x1A,W
265E:  CLRF   03
2660:  MOVLB  0
2662:  RCALL  226A
2664:  TBLRD*+
2666:  MOVFF  FF5,03
266A:  MOVWF  33
....................             if (usb_getdesc_ptr!=0xFF) { 
266C:  INCFSZ 33,W
266E:  BRA    2672
2670:  BRA    267E
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
2672:  CLRF   03
2674:  MOVF   33,W
2676:  RCALL  2206
2678:  MOVWF  34
....................                break; 
267A:  BRA    26C0
....................             } 
....................             else { 
267C:  BRA    2682
....................                usb_request_stall(); 
267E:  RCALL  257C
....................                return; 
2680:  BRA    26D8
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
2682:  BCF    FD8.0
2684:  MOVLB  4
2686:  RLCF   x1C,W
2688:  CLRF   03
268A:  MOVLB  0
268C:  RCALL  21DE
268E:  TBLRD*+
2690:  MOVFF  FF5,03
2694:  MOVWF  33
....................             if (usb_getdesc_ptr !=0xFF) { 
2696:  INCFSZ 33,W
2698:  BRA    269C
269A:  BRA    26B8
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
269C:  MOVLW  01
269E:  MOVWF  2E
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
26A0:  BCF    FD8.0
26A2:  MOVLB  4
26A4:  RLCF   x1C,W
26A6:  CLRF   03
26A8:  MOVLB  0
26AA:  RCALL  21F2
26AC:  TBLRD*+
26AE:  MOVFF  FF5,03
26B2:  MOVWF  34
....................                break; 
26B4:  BRA    26C0
....................             } 
....................             else { 
26B6:  BRA    26BC
....................                usb_request_stall(); 
26B8:  RCALL  257C
....................                return; 
26BA:  BRA    26D8
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
26BC:  RCALL  257C
....................             return; 
26BE:  BRA    26D8
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
26C0:  MOVLB  4
26C2:  MOVF   x1F,F
26C4:  BNZ   26D0
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
26C6:  MOVF   34,W
26C8:  SUBWF  x1E,W
26CA:  BC    26D0
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
26CC:  MOVFF  41E,34
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
26D0:  MOVLW  01
26D2:  MOVWF  2B
....................    usb_copy_desc_seg_to_ep(); 
26D4:  MOVLB  0
26D6:  RCALL  2580
.................... } 
26D8:  RETURN 0
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
2CE6:  CLRF   2C
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
2CE8:  CLRF   2B
....................    usb_set_address(USB_address_pending); 
2CEA:  MOVFF  32,91
2CEE:  BRA    2CD0
....................    #endif 
.................... } 
2CF0:  GOTO   2D08 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
2580:  CLRF   x91
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
2582:  MOVF   34,F
2584:  BZ    25D8
2586:  MOVF   x91,W
2588:  SUBLW  3F
258A:  BNC   25D8
....................       switch(USB_stack_status.getdesc_type) { 
258C:  MOVF   2E,W
258E:  ADDLW  FC
2590:  BC    25BE
2592:  ADDLW  04
2594:  GOTO   25EC
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
2598:  CLRF   03
259A:  MOVF   33,W
259C:  RCALL  2206
259E:  MOVWF  x92
....................             break; 
25A0:  BRA    25BE
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
25A2:  CLRF   03
25A4:  MOVF   33,W
25A6:  RCALL  215A
25A8:  MOVWF  x92
....................             break; 
25AA:  BRA    25BE
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
25AC:  CLRF   03
25AE:  MOVF   33,W
25B0:  RCALL  22B4
25B2:  MOVWF  x92
....................             break; 
25B4:  BRA    25BE
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
25B6:  CLRF   03
25B8:  MOVF   33,W
25BA:  RCALL  227E
25BC:  MOVWF  x92
....................             break; 
....................       } 
....................       usb_getdesc_ptr++; 
25BE:  INCF   33,F
....................       usb_getdesc_len--; 
25C0:  DECF   34,F
....................       usb_ep0_tx_buffer[i++]=c; 
25C2:  MOVF   x91,W
25C4:  INCF   x91,F
25C6:  CLRF   03
25C8:  ADDLW  58
25CA:  MOVWF  FE9
25CC:  MOVLW  04
25CE:  ADDWFC 03,W
25D0:  MOVWF  FEA
25D2:  MOVFF  92,FEF
....................    } 
25D6:  BRA    2582
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
25D8:  MOVF   34,F
25DA:  BNZ   25E4
25DC:  MOVF   x91,W
25DE:  SUBLW  40
25E0:  BZ    25E4
....................          USB_stack_status.dev_req = NONE; 
25E2:  CLRF   2B
....................    } 
....................  
....................    usb_request_send_response(i); 
25E4:  MOVFF  91,93
25E8:  RCALL  2576
.................... } 
25EA:  RETURN 0
....................  
.................... #ENDIF 
....................  
....................  
....................  
.................... #include "KeyboardKeys.h" 
.................... /** 
....................    KeyboardKeys.h 
....................     
....................    This header file contains the definitions for de corresponding key codes to 
....................    most of the keyboard keys. 
....................    It is VERY IMPORTANT that the keyboard language is set to: 
....................     
....................    English (United States - International) or equivalent. 
....................     
....................    This is because the key distribution and their corresponding key codes change 
....................    between keyboard languages. 
....................     
....................    Some key codes have been changed to implement them with the keyboard  
....................    functions, so any change to this definitions could cause unpredictable results 
....................    when using the keyboard functions. 
....................     
....................    For mor information, please check the documentation "USB HID Devices.pdf" on 
....................    page 53. 
....................     
....................    -- 
....................    Created: 02 ene 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics 
.................... */ 
....................  
.................... #define KEY_EXCLAMATION    30 
.................... #define KEY_ARROBA         31 
.................... #define KEY_SHARP          32 
.................... #define KEY_MONEY          33 
.................... #define KEY_PERCENT        34 
.................... #define KEY_POWER          35 
.................... #define KEY_AND            36 
.................... #define KEY_ASTERISC       37 
.................... #define KEY_PARENT_OPEN    38 
.................... #define KEY_PARENT_CLOSE   39 
....................  
.................... #define KEY_SPACEBAR          44 
.................... #define KEY_HYPHEN            45 
.................... #define KEY_UNDERSCORE        45 
.................... #define KEY_EQUAL             46 
.................... #define KEY_BRACE_OPEN        47 
.................... #define KEY_CURLY_BRACE_OPEN  47 
.................... #define KEY_BRACE_CLOSE       48 
.................... #define KEY_CURLY_BRACE_CLOSE 48 
.................... #define KEY_SLASH             49 
.................... #define KEY_OR                49 
....................  
.................... #define KEY_SEMICOLON      51 
.................... #define KEY_COLON          51 
.................... #define KEY_SINGLE_QUOTE   52 
.................... #define KEY_QUOTE          52 
.................... #define KEY_COMMA          54 
.................... #define KEY_ANGLE_OPEN     54 
.................... #define KEY_DOT            55 
.................... #define KEY_ANGLE_CLOSE    55 
.................... #define KEY_QUESTION       56 
....................  
.................... #define KEY_KEYPAD_DIVIDE     84 
.................... #define KEY_KEYPAD_MULTIPLY   85 
.................... #define KEY_KEYPAD_MINUS      86 
.................... #define KEY_KEYPAD_PLUS       87 
.................... #define KEY_KEYPAD_DOT        99 
....................  
.................... /** 
.................... *  These key codes correspond to the USB HID Usage Table plus 100, for example, 
.................... *  the actual KEY_UP_ARROW key code is 182 - 100 = 82 
.................... */ 
....................  
.................... #define KEY_PRINT_SCREEN      170 
.................... #define KEY_KEYPAD_ENTER      188 
....................  
.................... /** 
.................... *  Modifier Keys 
.................... *  A modifier key is a special key on a computer keyboard that modifies the  
.................... *  normal action of another key when the two are pressed in combination. 
.................... */ 
....................  
.................... #define KEY_LEFT_CTRL      1 
.................... #define KEY_LEFT_SHIFT     2 
.................... #define KEY_LEFT_ALT       4 
.................... #define KEY_LEFT_GUI       8 
....................  
.................... #define KEY_UP_ARROW       182 
.................... #define KEY_DOWN_ARROW     181 
.................... #define KEY_LEFT_ARROW     180 
.................... #define KEY_RIGHT_ARROW    179 
.................... #define KEY_BACKSPACE      142 
.................... #define KEY_TAB            143 
.................... #define KEY_RETURN         140 
.................... #define KEY_ESC            141 
.................... #define KEY_INSERT         173 
.................... #define KEY_DELETE         176 
.................... #define KEY_PAGE_UP        175 
.................... #define KEY_PAGE_DOWN      178 
.................... #define KEY_HOME           174 
.................... #define KEY_END            177 
.................... #define KEY_CAPS_LOCK      157 
.................... #define KEY_F1             158 
.................... #define KEY_F2             159 
.................... #define KEY_F3             160 
.................... #define KEY_F4             161 
.................... #define KEY_F5             162 
.................... #define KEY_F6             163 
.................... #define KEY_F7             164 
.................... #define KEY_F8             165 
.................... #define KEY_F9             166 
.................... #define KEY_F10            167 
.................... #define KEY_F11            168 
.................... #define KEY_F12            169 
....................  
.................... #ignore_warnings 216 
....................  
.................... #define _mouse_ep     1 
.................... #define _keyboard_ep  2 
....................  
.................... int pressedKeys[7]; 
.................... int mouseData[4]; 
.................... int _i; 
....................  
.................... /** 
.................... *  Starts emulating a keyboard connected to a computer.  
.................... */ 
.................... void KeyboardMouse_begin() { 
....................    usb_init(); 
*
2F70:  BRA    2F3A
....................    delay_ms(500); 
2F72:  MOVLW  02
2F74:  MOVWF  x78
2F76:  MOVLW  FA
2F78:  MOVWF  x7C
2F7A:  RCALL  2F48
2F7C:  DECFSZ x78,F
2F7E:  BRA    2F76
.................... } 
2F80:  GOTO   33D8 (RETURN)
....................  
.................... #include "Keyboard_Library.c" 
.................... /** 
....................    Keyboard_Library 
....................     
....................    Las funciones de teclado permiten a la G-PiC Lite! mandar pulsaciones de  
....................    teclas a la computadora conectada. 
....................     
....................    No todos los caracteres ASCII posibles, particularmente los no-visibles, 
....................    pueden ser enviados con la librería Keyboard_Library. La librería soporta 
....................    el uso de teclas modificadoras. Las teclas modificadoras cambian el  
....................    comportamiento de otras teclas cuando son presionadas simultáneamente. 
....................     
....................    Para mayor información acerca de las teclas soportadas por esta librería, 
....................    favor de ver el archivo <KeyboardKeys.h> 
....................    
....................    Esta librería está basada en la librería Arduino MouseKeyboard: 
....................       +  http://arduino.cc/en/Reference/MouseKeyboard 
....................     
....................    -- 
....................    Created: 15 feb 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics 
.................... */ 
....................  
.................... /** 
....................    Recibe un caracter ASCII y devuelve su código de tecla del teclado  
....................    correspondiente. La tecla shift es presionada de forma automática en caso de 
....................    ser necesario. 
....................     
....................    Sintaxis 
....................    charToKey(character); 
....................     
....................    Parametros 
....................    character: El caracter ASCII del cual se de sea obtener su código de tecla. 
....................     
....................    Devuelve 
....................    El código de tecla correspondiente 
.................... */ 
.................... int charToKey(char _char) { 
....................    // Characters that require SHIFT modifier key 
....................    bit_set(pressedKeys[0], 1);         // Press the SHIFT key 
2F84:  BSF    37.1
....................    if(_char == '!')        return(KEY_EXCLAMATION); 
2F86:  MOVF   x7C,W
2F88:  SUBLW  21
2F8A:  BNZ   2F94
2F8C:  MOVLW  1E
2F8E:  MOVWF  01
2F90:  BRA    3150
....................    else if(_char == '"')   return(KEY_QUOTE); 
2F92:  BRA    309A
2F94:  MOVF   x7C,W
2F96:  SUBLW  22
2F98:  BNZ   2FA2
2F9A:  MOVLW  34
2F9C:  MOVWF  01
2F9E:  BRA    3150
....................    else if(_char == '#')   return(KEY_SHARP); 
2FA0:  BRA    309A
2FA2:  MOVF   x7C,W
2FA4:  SUBLW  23
2FA6:  BNZ   2FB0
2FA8:  MOVLW  20
2FAA:  MOVWF  01
2FAC:  BRA    3150
....................    else if(_char == '$')   return(KEY_MONEY); 
2FAE:  BRA    309A
2FB0:  MOVF   x7C,W
2FB2:  SUBLW  24
2FB4:  BNZ   2FBE
2FB6:  MOVLW  21
2FB8:  MOVWF  01
2FBA:  BRA    3150
....................    else if(_char == '%')   return(KEY_PERCENT); 
2FBC:  BRA    309A
2FBE:  MOVF   x7C,W
2FC0:  SUBLW  25
2FC2:  BNZ   2FCC
2FC4:  MOVLW  22
2FC6:  MOVWF  01
2FC8:  BRA    3150
....................    else if(_char == '&')   return(KEY_AND); 
2FCA:  BRA    309A
2FCC:  MOVF   x7C,W
2FCE:  SUBLW  26
2FD0:  BNZ   2FDA
2FD2:  MOVLW  24
2FD4:  MOVWF  01
2FD6:  BRA    3150
....................    else if(_char == '/')   return(KEY_KEYPAD_DIVIDE); 
2FD8:  BRA    309A
2FDA:  MOVF   x7C,W
2FDC:  SUBLW  2F
2FDE:  BNZ   2FE8
2FE0:  MOVLW  54
2FE2:  MOVWF  01
2FE4:  BRA    3150
....................    else if(_char == '(')   return(KEY_PARENT_OPEN); 
2FE6:  BRA    309A
2FE8:  MOVF   x7C,W
2FEA:  SUBLW  28
2FEC:  BNZ   2FF6
2FEE:  MOVLW  26
2FF0:  MOVWF  01
2FF2:  BRA    3150
....................    else if(_char == ')')   return(KEY_PARENT_CLOSE); 
2FF4:  BRA    309A
2FF6:  MOVF   x7C,W
2FF8:  SUBLW  29
2FFA:  BNZ   3004
2FFC:  MOVLW  27
2FFE:  MOVWF  01
3000:  BRA    3150
....................    else if(_char == '_')   return(KEY_UNDERSCORE); 
3002:  BRA    309A
3004:  MOVF   x7C,W
3006:  SUBLW  5F
3008:  BNZ   3012
300A:  MOVLW  2D
300C:  MOVWF  01
300E:  BRA    3150
....................    else if(_char == '+')   return(KEY_KEYPAD_PLUS); 
3010:  BRA    309A
3012:  MOVF   x7C,W
3014:  SUBLW  2B
3016:  BNZ   3020
3018:  MOVLW  57
301A:  MOVWF  01
301C:  BRA    3150
....................    else if(_char == '{')   return(KEY_CURLY_BRACE_OPEN); 
301E:  BRA    309A
3020:  MOVF   x7C,W
3022:  SUBLW  7B
3024:  BNZ   302E
3026:  MOVLW  2F
3028:  MOVWF  01
302A:  BRA    3150
....................    else if(_char == '}')   return(KEY_CURLY_BRACE_CLOSE); 
302C:  BRA    309A
302E:  MOVF   x7C,W
3030:  SUBLW  7D
3032:  BNZ   303C
3034:  MOVLW  30
3036:  MOVWF  01
3038:  BRA    3150
....................    else if(_char == '|')   return(KEY_OR); 
303A:  BRA    309A
303C:  MOVF   x7C,W
303E:  SUBLW  7C
3040:  BNZ   304A
3042:  MOVLW  31
3044:  MOVWF  01
3046:  BRA    3150
....................    else if(_char == ':')   return(KEY_COLON); 
3048:  BRA    309A
304A:  MOVF   x7C,W
304C:  SUBLW  3A
304E:  BNZ   3058
3050:  MOVLW  33
3052:  MOVWF  01
3054:  BRA    3150
....................    else if(_char == '<')   return(KEY_ANGLE_OPEN); 
3056:  BRA    309A
3058:  MOVF   x7C,W
305A:  SUBLW  3C
305C:  BNZ   3066
305E:  MOVLW  36
3060:  MOVWF  01
3062:  BRA    3150
....................    else if(_char == '>')   return(KEY_ANGLE_CLOSE); 
3064:  BRA    309A
3066:  MOVF   x7C,W
3068:  SUBLW  3E
306A:  BNZ   3074
306C:  MOVLW  37
306E:  MOVWF  01
3070:  BRA    3150
....................    else if(_char == '?')   return(KEY_QUESTION); 
3072:  BRA    309A
3074:  MOVF   x7C,W
3076:  SUBLW  3F
3078:  BNZ   3082
307A:  MOVLW  38
307C:  MOVWF  01
307E:  BRA    3150
....................    else if(_char >= 'A' && _char <= 'Z')  return(_char - 61);  //Upscore letters 
3080:  BRA    309A
3082:  MOVF   x7C,W
3084:  SUBLW  40
3086:  BC    3098
3088:  MOVF   x7C,W
308A:  SUBLW  5A
308C:  BNC   3098
308E:  MOVLW  3D
3090:  SUBWF  x7C,W
3092:  MOVWF  01
3094:  BRA    3150
....................    else  bit_clear(pressedKeys[0], 1); // Release the SHIFT key 
3096:  BRA    309A
3098:  BCF    37.1
....................     
....................    // Characters that DON'T require SHIFT modifier key 
....................    if(_char >= 'a' && _char <= 'z') return(_char - 93);  // Downscore letters 
309A:  MOVF   x7C,W
309C:  SUBLW  60
309E:  BC    30AE
30A0:  MOVF   x7C,W
30A2:  SUBLW  7A
30A4:  BNC   30AE
30A6:  MOVLW  5D
30A8:  SUBWF  x7C,W
30AA:  MOVWF  01
30AC:  BRA    3150
....................    if(_char >= '1' && _char <= '9') return(_char - 19);  // Numbers 
30AE:  MOVF   x7C,W
30B0:  SUBLW  30
30B2:  BC    30C2
30B4:  MOVF   x7C,W
30B6:  SUBLW  39
30B8:  BNC   30C2
30BA:  MOVLW  13
30BC:  SUBWF  x7C,W
30BE:  MOVWF  01
30C0:  BRA    3150
....................    if(_char == '0')  return(39);                         // Number 0 
30C2:  MOVF   x7C,W
30C4:  SUBLW  30
30C6:  BNZ   30CE
30C8:  MOVLW  27
30CA:  MOVWF  01
30CC:  BRA    3150
....................    if(_char == ' ')  return(KEY_SPACEBAR); 
30CE:  MOVF   x7C,W
30D0:  SUBLW  20
30D2:  BNZ   30DA
30D4:  MOVLW  2C
30D6:  MOVWF  01
30D8:  BRA    3150
....................    if(_char == '-')  return(KEY_HYPHEN); 
30DA:  MOVF   x7C,W
30DC:  SUBLW  2D
30DE:  BNZ   30E6
30E0:  MOVLW  2D
30E2:  MOVWF  01
30E4:  BRA    3150
....................    if(_char == '=')  return(KEY_EQUAL); 
30E6:  MOVF   x7C,W
30E8:  SUBLW  3D
30EA:  BNZ   30F2
30EC:  MOVLW  2E
30EE:  MOVWF  01
30F0:  BRA    3150
....................    if(_char == '[')  return(KEY_BRACE_OPEN); 
30F2:  MOVF   x7C,W
30F4:  SUBLW  5B
30F6:  BNZ   30FE
30F8:  MOVLW  2F
30FA:  MOVWF  01
30FC:  BRA    3150
....................    if(_char == ']')  return(KEY_BRACE_CLOSE); 
30FE:  MOVF   x7C,W
3100:  SUBLW  5D
3102:  BNZ   310A
3104:  MOVLW  30
3106:  MOVWF  01
3108:  BRA    3150
....................    if(_char == '\\') return(KEY_SLASH); 
310A:  MOVF   x7C,W
310C:  SUBLW  5C
310E:  BNZ   3116
3110:  MOVLW  31
3112:  MOVWF  01
3114:  BRA    3150
....................    if(_char == ';')  return(KEY_SEMICOLON); 
3116:  MOVF   x7C,W
3118:  SUBLW  3B
311A:  BNZ   3122
311C:  MOVLW  33
311E:  MOVWF  01
3120:  BRA    3150
....................    if(_char == '\'') return(KEY_SINGLE_QUOTE); 
3122:  MOVF   x7C,W
3124:  SUBLW  27
3126:  BNZ   312E
3128:  MOVLW  34
312A:  MOVWF  01
312C:  BRA    3150
....................    if(_char == ',')  return(KEY_COMMA); 
312E:  MOVF   x7C,W
3130:  SUBLW  2C
3132:  BNZ   313A
3134:  MOVLW  36
3136:  MOVWF  01
3138:  BRA    3150
....................    if(_char == '.')  return(KEY_DOT); 
313A:  MOVF   x7C,W
313C:  SUBLW  2E
313E:  BNZ   3146
3140:  MOVLW  37
3142:  MOVWF  01
3144:  BRA    3150
....................    if(_char == '*')  return(KEY_KEYPAD_MULTIPLY); 
3146:  MOVF   x7C,W
3148:  SUBLW  2A
314A:  BNZ   3150
314C:  MOVLW  55
314E:  MOVWF  01
....................     
.................... } 
3150:  GOTO   3226 (RETURN)
....................  
.................... /** 
....................    Libera todas las teclas presionadas. Para mayor información, ver  
....................    keyboard_press() 
....................     
....................    Sintaxis 
....................    keyboard_releaseAll(); 
....................     
....................    Parametros 
....................    - 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void keyboard_releaseAll() { 
....................    pressedKeys[0] = 0; 
*
3248:  CLRF   37
....................    pressedKeys[2] = 0; 
324A:  CLRF   39
....................     
....................    usb_put_packet(_keyboard_ep, pressedKeys, sizeOf(pressedKeys), USB_DTS_TOGGLE); 
324C:  MOVLW  02
324E:  MOVWF  x7C
3250:  CLRF   x7E
3252:  MOVLW  37
3254:  MOVWF  x7D
3256:  CLRF   x80
3258:  MOVLW  07
325A:  MOVWF  x7F
325C:  MOVLW  02
325E:  MOVWF  x81
3260:  RCALL  3154
....................    delay_ms(15); 
3262:  MOVLW  0F
3264:  MOVWF  x7C
3266:  RCALL  2F48
.................... } 
3268:  RETURN 0
....................  
.................... /** 
....................    Esta función se comporta como si la tecla especificada fuera presionada 
....................    continuamente. Esta función es útil cuando se emplean teclas modificadoras. 
....................    Para finalizar la presión de una tecla, es necesario utilizar  
....................    keyboard_releaseAll(); 
....................    Es necesario llamar a KeyboardMouse_begin() antes de utilizar keyboard_press() 
....................     
....................    Sintaxis 
....................    keyboard_press(key); 
....................     
....................    Parametros 
....................    key: la tecla que se desea presionar 
....................     
....................    Devuelve 
....................    -    
.................... */ 
.................... void keyboard_press(char _key) { 
....................    if(_key == KEY_LEFT_CTRL || _key == KEY_LEFT_SHIFT || _key == KEY_LEFT_ALT || _key == KEY_LEFT_GUI) { 
*
31F4:  DECFSZ x7B,W
31F6:  BRA    31FA
31F8:  BRA    320C
31FA:  MOVF   x7B,W
31FC:  SUBLW  02
31FE:  BZ    320C
3200:  MOVF   x7B,W
3202:  SUBLW  04
3204:  BZ    320C
3206:  MOVF   x7B,W
3208:  SUBLW  08
320A:  BNZ   3212
....................       pressedKeys[0] = pressedKeys[0] + _key;    
320C:  MOVF   x7B,W
320E:  ADDWF  37,F
....................    } 
....................    else if(_key > 127) {                     // Any other modifier key 
3210:  BRA    322A
3212:  MOVF   x7B,W
3214:  SUBLW  7F
3216:  BC    3220
....................       pressedKeys[2] = _key-100; 
3218:  MOVLW  64
321A:  SUBWF  x7B,W
321C:  MOVWF  39
....................    } 
....................    else  pressedKeys[2] = charToKey(_key);   // Characters key 
321E:  BRA    322A
3220:  MOVFF  7B,7C
3224:  BRA    2F84
3226:  MOVFF  01,39
....................     
....................    usb_put_packet(_keyboard_ep, pressedKeys, sizeOf(pressedKeys), USB_DTS_TOGGLE);; 
322A:  MOVLW  02
322C:  MOVWF  x7C
322E:  CLRF   x7E
3230:  MOVLW  37
3232:  MOVWF  x7D
3234:  CLRF   x80
3236:  MOVLW  07
3238:  MOVWF  x7F
323A:  MOVLW  02
323C:  MOVWF  x81
323E:  RCALL  3154
....................    delay_ms(15); 
3240:  MOVLW  0F
3242:  MOVWF  x7C
3244:  RCALL  2F48
.................... } 
3246:  RETURN 0
....................  
.................... /** 
....................    Envía la presión de una tecla a la computadora conectada. Esto es similar a  
....................    presionar y soltar una tecla de tu teclado. Es posible enviar algunos 
....................    caracteres ASCII o los modificadores de teclado y teclas especiales. 
....................     
....................    Solo son soportados los caracteres ASCII que se encuentran en el teclado.  
....................    Por ejemplo, ASCII 8 (Retroceso) podría funcionar, pero ASCII 25 (sustitución) 
....................    no podría. Al enviar letras mayúsculas, keyboard_write() envía el comando 
....................    Shift más el caracter deseado, al igual que si se presionara en el teclado. 
....................    Si se envía un valor numérico, la función lo envía a la computadora como su 
....................    equivalente en caracter ASCII (keyboard_write(97) enviará una 'a'). 
....................     
....................    Para una lista completa de caracteres ASCII favor de referirse a  
....................       + http://www.asciitable.com/ 
....................        
....................    Sintaxis 
....................    keyboard_write(caracter); 
....................     
....................    Parametros 
....................    caracter: un char o un int que será enviado a la computadora. Puede ser  
....................             enviado en cualquier notación que sea aceptable para un char. Por 
....................             ejemplo, todos los de abajo son aceptables y envían el mismo valor, 
....................             65 o ASCII 'A': 
....................             Keyboard.write(65);         // Envía valor ASCII 65, o 'A'  
....................             Keyboard.write('A');        // Lo mismo pero con el caracter 'A' 
....................             Keyboard.write(0x41);       // Lo mismo pero en hexadecimal 
....................             Keyboard.write(0b01000001); // Lo mismo pero en binario 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void keyboard_write(char __key) { 
....................    keyboard_press(__key); 
*
334A:  MOVFF  7A,7B
334E:  RCALL  31F4
....................    keyboard_releaseAll(); 
3350:  RCALL  3248
.................... } 
3352:  GOTO   338E (RETURN)
....................  
.................... /** 
....................    Envía la presión de teclas hacia la computadora conectada. keyboard_print() 
....................    debe ser llamado después de haber inicializado mediante KeyboadMouse_begin(). 
....................  
....................    ADVERTENCIA: Al usar el comando keyboard_print(), la G-PiC Lite! toma el 
....................    control de tu teclado! Asegúrate de tener el control antes de utilizar este 
....................    comando. Se recomienda utilizar un push button para activar/desactivar  
....................    esta función. 
....................     
....................    Sintaxis 
....................    char text[] = "Texto a teclear!"; 
....................    keyboard_print(text); 
....................     
....................    Parametros 
....................    text: la cadena de caracteres que se desea teclear. Es necesario guardar 
....................    esta cadena en una arreglo tipo char y luego pasar este arreglo como parámetro 
....................    de la función keyboard_print(). 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void keyboard_print(char _text[]) { 
....................    for(_i = 0; _text[_i] != '\0'; _i++) { 
*
326A:  CLRF   42
326C:  CLRF   03
326E:  MOVF   42,W
3270:  ADDWF  x78,W
3272:  MOVWF  FE9
3274:  MOVF   x79,W
3276:  ADDWFC 03,W
3278:  MOVWF  FEA
327A:  MOVF   FEF,F
327C:  BZ    329A
....................       keyboard_press(_text[_i]); 
327E:  CLRF   03
3280:  MOVF   42,W
3282:  ADDWF  x78,W
3284:  MOVWF  FE9
3286:  MOVF   x79,W
3288:  ADDWFC 03,W
328A:  MOVWF  FEA
328C:  MOVFF  FEF,7A
3290:  MOVFF  7A,7B
3294:  RCALL  31F4
....................    } 
3296:  INCF   42,F
3298:  BRA    326C
....................  
....................    keyboard_releaseAll(); 
329A:  RCALL  3248
.................... } 
329C:  RETURN 0
....................  
.................... /** 
....................    Realiza la misma función que keyboard_print() pero al final del texto manda 
....................    la tecla RETURN (Enter) para realizar un salto de línea. 
....................     
....................    Sintaxis 
....................    char text[] = "Texto a teclear!"; 
....................    keyboard_print(text); 
....................     
....................    Parametros 
....................    text: la cadena de caracteres que se desea teclear. Es necesario guardar 
....................    esta cadena en una arreglo tipo char y luego pasar este arreglo como parámetro 
....................    de la función keyboard_print(). 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void keyboard_println(char _text[]) { 
....................    for(_i = 0; _text[_i] != '\0'; _i++) { 
*
3356:  CLRF   42
3358:  CLRF   03
335A:  MOVF   42,W
335C:  ADDWF  x78,W
335E:  MOVWF  FE9
3360:  MOVF   x79,W
3362:  ADDWFC 03,W
3364:  MOVWF  FEA
3366:  MOVF   FEF,F
3368:  BZ    3386
....................       keyboard_press(_text[_i]); 
336A:  CLRF   03
336C:  MOVF   42,W
336E:  ADDWF  x78,W
3370:  MOVWF  FE9
3372:  MOVF   x79,W
3374:  ADDWFC 03,W
3376:  MOVWF  FEA
3378:  MOVFF  FEF,7A
337C:  MOVFF  7A,7B
3380:  RCALL  31F4
....................    } 
3382:  INCF   42,F
3384:  BRA    3358
....................     
....................    keyboard_releaseAll(); 
3386:  RCALL  3248
....................     
....................    keyboard_write(KEY_RETURN); 
3388:  MOVLW  8C
338A:  MOVWF  x7A
338C:  BRA    334A
.................... } 
338E:  GOTO   3482 (RETURN)
....................  
.................... #include "KeyboardMacros.c" 
....................    /** 
....................    KeyboardMacros.c 
....................  
....................    For the G-PiC and G-PiC Lite! 
....................     
....................    This library implements some keyboard macros commonly used in Windows OS. 
....................    All the macros use the keyboard_releaseAll() function. 
....................    
....................    New macros can be created following the existing macros structure. 
....................     
....................    Additional Windows OS macros can be found on this website: 
....................        
....................    http://es.scribd.com/doc/16783931/Teclas-De-Acceso-Rapido-Para-Windows 
....................    
....................    This macros were designed to work with the keyboard language: 
....................    
....................    English (United States - International) 
....................   
....................    -- 
....................    Created: 02 ene 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics 
.................... */ 
....................  
.................... /** 
.................... *  Prints page.  
.................... *  Sends Ctrl + p keystrokes. 
.................... */ 
.................... void keyboard_print_page() { 
....................    keyboard_press(KEY_LEFT_CTRL); 
....................    keyboard_press('p'); 
....................    delay_ms(100); 
....................    keyboard_releaseAll(); 
....................    delay_ms(500); 
....................    keyboard_write(KEY_RETURN); 
.................... } 
....................  
.................... /** 
.................... *  New document.  
.................... *  Sends Ctrl + n keystrokes. 
.................... */ 
.................... void keyboard_new_document() { 
....................    keyboard_press(KEY_LEFT_CTRL); 
....................    keyboard_press('n'); 
....................    delay_ms(100); 
....................    keyboard_releaseAll(); 
.................... } 
....................  
.................... /** 
.................... *  Close window.  
.................... *  Sends Alt + F4 keystrokes. 
.................... */ 
.................... void keyboard_close_window() { 
....................    keyboard_press(KEY_LEFT_ALT); 
....................    keyboard_press(KEY_F4); 
....................    delay_ms(100); 
....................    keyboard_releaseAll(); 
.................... } 
.................... /** 
.................... *  Task Switcher.  
.................... *  Sends Alt + F4 keystrokes. 
.................... */ 
.................... void keyboard_switch_task() { 
....................    keyboard_press(KEY_LEFT_ALT); 
....................    keyboard_press(KEY_TAB); 
....................    delay_ms(100); 
....................    keyboard_releaseAll(); 
.................... } 
....................  
....................  
....................  
.................... #include "Mouse_Library.c" 
.................... /** 
....................    Mouse_Library.c 
....................     
....................    Las funciones de mouse incluidas en esta librería permiten a la G-PiC Lite! 
....................    controlar el movimiento del cursor en una computadora conectada. La  
....................    actualización de la posición del cursor siempre es relativo a la posición  
....................    anterior.  
....................     
....................    Esta librería está basada en la librería Arduino MouseKeyboard 
....................       + http://arduino.cc/en/Reference/MouseKeyboard 
....................        
....................    -- 
....................    Created: 15 feb 2013 
....................    By:      Ing. Ayrton Estrella Alcocer 
....................             G-PiC Electronics    
.................... */ 
....................  
.................... #define MOUSE_LEFT   1 
.................... #define MOUSE_RIGHT  2 
.................... #define MOUSE_MIDDLE 3 
....................  
.................... /** 
....................    Libera cualquier botón del mouse que haya sido presionado. También puede 
....................    ser utilizado para detener el movimiento del cursor. 
....................     
....................    Sintaxis 
....................    mouse_release(); 
....................     
....................    Parametros 
....................    - 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void mouse_release() { 
....................    mouseData[0] = 0; 
....................    mouseData[1] = 0; 
....................    mouseData[2] = 0; 
....................    mouseData[3] = 0; 
....................     
....................    usb_put_packet(_mouse_ep, mouseData, sizeOf(mouseData), USB_DTS_TOGGLE); 
.................... } 
....................  
.................... /** 
....................    Envia un click momentáneo a la computadora en la ubicación del cursor. Esto 
....................    es lo mismo que presionar y soltar el botón del mouse. 
....................     
....................    mouse_click() presiona por default el botón izquierdo del mouse. 
....................     
....................    Sintaxis 
....................    mouse_click(); 
....................    mouse_click(button); 
....................     
....................    Parametros: 
....................    button: el botón del mouse a presionar 
....................       + MOUSE_LEFT (default) 
....................       + MOUSE_RIGHT 
....................       + MOUSE_MIDDLE 
....................        
....................    Devuelve 
....................    - 
.................... */ 
.................... void mouse_click(int _button = MOUSE_LEFT) { 
....................    mouseData[0] = _button; 
....................    usb_put_packet(_mouse_ep, mouseData, sizeOf(mouseData), USB_DTS_TOGGLE); 
....................     
....................    delay_ms(100); 
....................    mouse_release(); 
.................... } 
....................  
.................... /** 
....................    Envia la presión de una botón a la computadora conectada. Una presión es 
....................    equivalente a hacer un click y sostener continuamente el botón del mouse. 
....................    Una presión es cancelada mediante mouse_release(); 
....................     
....................    Antes de utilizar mouse_press(), es necesario iniciar la comunicación 
....................    mediante KeyboardMouse_begin(). 
....................     
....................    mouse_press() presiona por default el botón izquierdo. 
....................     
....................    Sintaxis 
....................    mouse_press(); 
....................    mouse_press(button); 
....................     
....................    Parametros 
....................    button: el botón del mouse a presionar 
....................       + MOUSE_LEFT (default) 
....................       + MOUSE_RIGHT 
....................       + MOUSE_MIDDLE 
....................     
....................    Devuelve 
....................    - 
.................... */ 
.................... void mouse_press(int _button = MOUSE_LEFT) { 
....................    mouseData[0] = _button; 
....................    usb_put_packet(_mouse_ep, mouseData, sizeOf(mouseData), USB_DTS_TOGGLE); 
.................... } 
....................  
.................... /** 
....................    Checa el estado actual del botón del mouse especificado y reporta si éste 
....................    está presionado. 
....................     
....................    mouse_isPressed() verifica por default el botón izquierdo. 
....................     
....................    Sintaxis 
....................    mouse_isPressed(); 
....................    mouse_isPressed(button); 
....................     
....................    Parametros 
....................    button: el botón del mouse a presionar 
....................       + MOUSE_LEFT (default) 
....................       + MOUSE_RIGHT 
....................       + MOUSE_MIDDLE 
....................     
....................    Devuelve 
....................       + true: si el botón especificado se encuentra presionado 
....................       + false: si el botón especificado NO se encuentra presionado 
.................... */ 
.................... int1 mouse_isPressed(int _button = MOUSE_LEFT) { 
....................    if(mouseData[0] == _button)   return(true); 
....................    else return(false); 
.................... } 
....................  
.................... /** 
....................    Mueve el cursor en una computadora conectada. El movimiento en pantalla 
....................    siempre es relativo a la posición actual del cursor. 
....................     
....................    ADVERTENCIA:  
....................    Al usar el comando mouse_move(), la G-PiC Lite! toma el 
....................    control de tu teclado! Asegúrate de tener el control antes de utilizar este 
....................    comando. Se recomienda utilizar un push button para activar/desactivar  
....................    esta función. 
....................     
....................    Sintaxis 
....................    mouse_move(deltaX, deltaY); 
....................    mouse_move(deltaX, deltaY, deltaWheel); 
....................     
....................    Parametros 
....................    deltaX:  incremento/decremento en la posición en X, un valor positivo moverá 
....................             el cursor hacia la derecha, un valor negativo lo moverá hacia la  
....................             izquierda. 
....................    deltaY:  incremento/decremento en la posición en Y, un valor positivo moverá 
....................             el cursor hacia arriba, un valor negativo lo moverá hacia abajo. 
....................    deltaWheel (opcional):  incremento/decremento en la posición de la rueda del 
....................                            mouse. un valor positivo moverá el cursor hacia  
....................                            arriba, un valor negativo lo moverá hacia abajo. 
....................                            Este valor es 0 en caso de no ser especificado. 
....................                             
....................    Devuelve 
....................    - 
.................... */ 
.................... void mouse_move(int _xVal, int _yVal, int _wheel = 0) { 
....................    _yVal = -_yVal; 
....................     
....................    mouseData[1] = _xVal; 
....................    mouseData[2] = _yVal; 
....................    mouseData[3] = _wheel; 
....................     
....................    usb_put_packet(_mouse_ep, mouseData, sizeOf(mouseData), USB_DTS_TOGGLE); 
....................    delay_ms(10); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #define buttonPin Pin_A4 
....................  
.................... void main() { 
3392:  CLRF   FF8
3394:  BCF    FD0.7
3396:  BSF    07.7
3398:  CLRF   FEA
339A:  CLRF   FE9
339C:  BCF    1B.4
339E:  BCF    1B.5
33A0:  MOVLW  01
33A2:  MOVWF  29
33A4:  CLRF   2A
33A6:  BSF    FB8.3
33A8:  MOVLW  E1
33AA:  MOVWF  FAF
33AC:  MOVLW  04
33AE:  MOVWF  FB0
33B0:  MOVLW  A6
33B2:  MOVWF  FAC
33B4:  MOVLW  90
33B6:  MOVWF  FAB
33B8:  BCF    F95.4
33BA:  BSF    F8C.4
33BC:  BCF    F95.6
33BE:  BSF    F8C.6
33C0:  CLRF   30
33C2:  CLRF   34
33C4:  CLRF   44
33C6:  CLRF   43
33C8:  MOVF   FC1,W
33CA:  ANDLW  C0
33CC:  IORLW  0F
33CE:  MOVWF  FC1
33D0:  MOVLW  07
33D2:  MOVWF  FB4
33D4:  CLRF   45
....................    int counter = 0; 
....................     
....................    KeyboardMouse_begin(); 
33D6:  BRA    2F70
....................        
....................    while(true) { 
....................       if(digitalRead(buttonPin) == 0) { 
33D8:  BSF    F92.4
33DA:  BTFSC  F80.4
33DC:  BRA    3490
....................          counter ++; 
33DE:  INCF   45,F
....................           
....................          // Crea una variable tipo arreglo (array) lo suficientemente 
....................          // grande para almacenar todos los caracteres de la cadena. 
....................          char text[50] = "Has presionado el boton "; 
33E0:  MOVLW  48
33E2:  MOVWF  46
33E4:  MOVLW  61
33E6:  MOVWF  47
33E8:  MOVLW  73
33EA:  MOVWF  48
33EC:  MOVLW  20
33EE:  MOVWF  49
33F0:  MOVLW  70
33F2:  MOVWF  4A
33F4:  MOVLW  72
33F6:  MOVWF  4B
33F8:  MOVLW  65
33FA:  MOVWF  4C
33FC:  MOVLW  73
33FE:  MOVWF  4D
3400:  MOVLW  69
3402:  MOVWF  4E
3404:  MOVLW  6F
3406:  MOVWF  4F
3408:  MOVLW  6E
340A:  MOVWF  50
340C:  MOVLW  61
340E:  MOVWF  51
3410:  MOVLW  64
3412:  MOVWF  52
3414:  MOVLW  6F
3416:  MOVWF  53
3418:  MOVLW  20
341A:  MOVWF  54
341C:  MOVLW  65
341E:  MOVWF  55
3420:  MOVLW  6C
3422:  MOVWF  56
3424:  MOVLW  20
3426:  MOVWF  57
3428:  MOVLW  62
342A:  MOVWF  58
342C:  MOVLW  6F
342E:  MOVWF  59
3430:  MOVLW  74
3432:  MOVWF  5A
3434:  MOVLW  6F
3436:  MOVWF  5B
3438:  MOVLW  6E
343A:  MOVWF  5C
343C:  MOVLW  20
343E:  MOVWF  5D
3440:  CLRF   5E
....................          keyboard_print(text);            // Imprime la cadena de caracteres 
3442:  CLRF   x79
3444:  MOVLW  46
3446:  MOVWF  x78
3448:  RCALL  326A
....................           
....................          // Convierte el valor de la variable a una cadena de caracteres y 
....................          // guarda el resultado en la variable <text>. Para mayor información, 
....................          // revisar el archivo de ayuda HELP. 
....................          sprintf(text, "%u", counter); 
344A:  CLRF   44
344C:  MOVLW  46
344E:  MOVWF  43
3450:  MOVFF  45,78
3454:  MOVLW  1B
3456:  MOVWF  x79
3458:  BRA    32E2
....................          keyboard_print(text);            // Imprime el valor de counter 
345A:  CLRF   x79
345C:  MOVLW  46
345E:  MOVWF  x78
3460:  RCALL  326A
....................           
....................          text = " veces!"; 
3462:  CLRF   FEA
3464:  MOVLW  46
3466:  MOVWF  FE9
3468:  MOVLW  00
346A:  CALL   2306
346E:  TBLRD*-
3470:  TBLRD*+
3472:  MOVF   FF5,W
3474:  MOVWF  FEE
3476:  IORLW  00
3478:  BNZ   3470
....................          keyboard_println(text);          // Imprime la cadena de caracteres 
347A:  CLRF   x79
347C:  MOVLW  46
347E:  MOVWF  x78
3480:  BRA    3356
....................           
....................          delay_ms(500); 
3482:  MOVLW  02
3484:  MOVWF  x78
3486:  MOVLW  FA
3488:  MOVWF  x7C
348A:  RCALL  2F48
348C:  DECFSZ x78,F
348E:  BRA    3486
....................       } 
....................    } 
3490:  BRA    33D8
.................... } 
3492:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
